(

					  HSP Narrator v5.6.4

	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	Copyright 2001-2005 by Alessandro Ghignola
	Copyright 2001-2005 Home Sweet Pixel software

	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	HSP Narrator main source code file - licensed under GNU Lesser General Public License.
	You need this source and the files found in the "build" folder to rebuild the program:
	all files in this package are to be considered parts of the program's source code, and
	subject to the same GNU LGPL license. This application is an authoring system and user
	works, composed by "storybook files" written in its particular marking language, along
	with their related pictures, may be licensed by their authors under different terms.

	LICENSE:
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	This library is free software; you can redistribute it and/or modify it under the
	terms of the GNU Lesser General Public License as published by the Free Software
	Foundation; either version 2.1 of the License, or, at your option, any later version.

	This library is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
	or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
	for more details.

	You should have received a copy of the GNU Lesser General Public License along with
	this library; if not, write to the Free Software Foundation, Inc., 59 Temple Place,
	Suite 330, Boston, MA 02111-1307 USA

	RECOMPILING:
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	To recompile this program you need a L.in.oleum compiler, version 1.14 or higher.
	You can get the latest version of the L.in.oleum compiler for free, at:

	  http://anywherebb.com/linoleum.html
	  http://0x44.com/linoleum.html

	...which are basically the same site, my site, under different domains.
	The L.in.oleum SDK is completely free for both home and professional use; however,
	please note that the L.in.oleum compiler's core parts, being the run-time modules,
	the instruction set implementations, and the self-coded compiler source code, are
	read-only open-source. This doesn't interfere in any ways with the standard rights
	granted to you by the GNU LGPL license applied to this particular application.

)

"libraries"

	igui/defstyle;	(include and use iGUI, with default style)

	gen/tgafont;	(allows writing with a TGA-encoded font typeface)
	gen/random;	(the Mersenne Twister, for every random numbers generation necessity)

	gen/lz; 	(Photolizzie [PLZ] graphics format support)
	gen/bytes;	(Photolizzie [PLZ] graphics format support)

      (select icon)

	build/sys/use/feather;



"stockfile"

	build/pushcurs; (feather, while hovering a link: PLZ-compressed, color mode)
	build/crescent; (text cursor's crescent: PLZ-compressed, color mode)
	build/trecrisp; ("trescrisp" font typeface: PLZ-compressed, greyscale mode)
	build/version;	(bottom-right version indication: PLZ-compressed, color mode)
	build/whatcurs; (feather, when no answer matches: PLZ-compressed, color mode)

	build/defstory; (default storybook, for when no valid storybook is loaded at startup)



"directors"

      (mandatory unit spec, program name for the taskbar to know)

	unit = 32;
	program name = { HSP_Narrator_v5.6.4 };

      (heh... overriding display window size to zero its visible area: it would flicker
       while it's being suddenly moved to the last recorded position, because of the OS
       being retracing what was behind it... not really necessary, but takes nothing...)

	display width = zero;
	display height = zero;



"constants"

      (The Narrator's display is fixed-width, to a very typical 640x480 resolution)

	constant width = 640;
	constant height = 480;

      (GUI setup constants: keep all dimensions and limits to above constant display size)

	initial width = constant width;
	initial height = constant height;
	minimum width = constant width;
	minimum height = constant height;
	maximum width = constant width;
	maximum height = constant height;

      (GUI setup constants: some generous amount of possible menu options)

	max menu options = 100;
	max onscreen options = 100;
	max levels in show = 4;

      (GUI setup constants: read upto 1000 files per folder, show upto 16)

	max files in selector = 1003; (3 extra name slots to account for "/", "." and "..")
	max files in show = 16;

      (GUI setup constants: upto four options per question and an eventual field for filenames)

	max options in question = 4;
	max fields in question = 1;

      (fundamental storybook complexity and memory limits:
       - 2 megabytes maximum ascii file size, 2 megaunits maximum symbolic file size,
       - on average, generously allow one symbol every 128 characters of storybook file,
       - allow upto 5000 characters per IF...FI block, 5000 being the condition to test,
       - interpreter stack: upto 1000 levels of recursion, or subroutine calls nidification,
       - let loader approximate storybook's memory requests in excess of 100 KiloUnits)

	max storybook size = 2 097 152;
	max number of symbols = max storybook size div 128;
	max characters in condition = 5000;
	max please calls = 1000;
	loader span size = 102400;

      (calculate text limits for a single page: pages can't be scrolled, so these are ultimate)

	max characters in answer = constant width div text font width;
	maximum lines = constant height div text line spacing;

      (a couple commodity constants: highest X and Y coordinates for a pixel on display)

	max hpixel = constant width minus 1;
	max vpixel = constant height minus 1;

      (symbol type definitions: 1 means a normal clause, 2 means a bookmark)

	symbol = 1;
	bookmark = 2;

      (keyword identificators: "NOT" and its synonyms;
       note: keyword identificators are formed by the hexadecimal values of the ASCII codes of
       the first 4 characters of keywords, in reverse order because we will be checking small-
       endian text files; if the keyword is shorter than 4 characters, extra bytes are zeroed.)

	not = 00544f4eh;
	nobody = 4f424f4eh;
	nothing = 48544f4eh;
	no more = 4d204f4eh;
	no longer = 4c204f4eh;
	no as string = 00004f4eh;

      (keyword identificators: all other keywords)

	randomize = 444e4152h;	(open RANDOMIZE...BY: assign to ranged pseudo-random number)
	actually = 55544341h;	(jump to bookmark, ie. GOTO...)
	indicate = 49444e49h;	(featured PUSH...TO span: same as PUSH, but coloured purple)
	multiply = 544c554dh;	(open MULTIPLY...BY: assign to result of multiplication)
	subtract = 54425553h;	(open SUBTRACT...FROM: assign to result of subtraction)
	atstory = 4f545340h;	(storybook validation cookie: @STORY)
	append = 45505041h;	(show picture, aligned to right display margin)
	please = 41454c50h;	(jump to subroutine bookmark, ie. GOSUB...)
	report = 4f504552h;	(report numeric value of a symbol)
	xivide = 49564944h;	(open DIVIDE...BY: assign to result of division)
	claim = 49414c43h;	(featured text span: same as SAY, but coloured orange)
	epoch = 434f5045h;	(EPOCH: numeric value returned as the seconds since January 1)
	every = 52455645h;	(opening EVERY...YREVE block)
	input = 55504e49h;	(INPUT: numeric value resulting from player answer)
	title = 4c544954h;	(set window title)
	yreve = 56455259h;	(closing EVERY...YREVE block)
	done = 454e4f44h;	(return from subroutine, or marks end of storybook)
	from = 4d4f5246h;	(close SUBTRACT...FROM, followed by second operand)
	note = 45544f4eh;	(declare comment span)
	push = 48535550h;	(open PUSH...TO span, ie. a clickable link to a subroutine)
	seed = 44454553h;	(SEED: select numeric random seed and re-initialize PRNG)
	show = 574f4853h;	(show picture, aligned to left display margin)
	xtop = 504f5453h;	(STOP: interrupt storybook execution and wait for player input)
	well = 4c4c4557h;	(bookmark: intended for subroutines, but interchangeable)
	when = 4e454857h;	(bookmark: intended for labels, but interchangeable)
	add = 00444441h;	(open ADD...TO: assign to result of addition)
	and = 00444e41h;	(conditional operator)
	but = 00545542h;	(conditional operator: synonym of AND)
	now = 00574f4eh;	(assert clause status or declare new clause)
	say = 00594153h;	(open text span, ie. PRINT...)
	if = 00004649h; 	(open IF...FI conditional block)
	fi = 00004946h; 	(close IF...FI conditional block)
	or = 0000524fh; 	(conditional operator, specifically it's an inclusive OR)
	to = 00004f54h; 	(close PUSH/ADD...TO, followed by subroutine name or operand)
	by = 00005942h; 	(close MULTIPLY/DIVIDE/RANDOMIZE...BY, followed by second op.)

      (A/L operator codes, to which < = > will be respectively translated)

	lessthan = 100h;
	equate = 101h;
	greaterthan = 102h;

      (A/L operation codes, as possible values for the parser's [operation] variable)

	addition = 0;
	subtraction = 1;
	multiplication = 2;
	xivision = 3;
	randomization = 4;

      (clickable areas' reference layer pixel identificators:
       on that reference layer, when the mouse hovers a pixel that's part of a clickable area,
       there will be the "address" to the first character of the subroutine to call; the two
       codes below identify, respectively, a non-clickable area and an area that's covered by
       either part of a picture, or an erased pixel from a word-wrapped edge...)

	nothing to push = greatest unsigned integer;
	spliced area = greatest unsigned integer minus 1;

      (text metrics, in pixels)

	text left margin = 8;
	text top margin = 32;
	text right margin = 16;
	text font width = 16;
	text font body = 19;
	text line spacing = 22;
	text cursor line top = minus 5;
	text cursor line bottom = plus 27;

      (TGA/PLZ image loaders: picture size and buffer limits, UI graphic parts pixel sizes)

	targa header = 69; (may be from 18 bytes to 18 + 255 = 273 bytes = 69 units)

	max picture width = 512;
	max picture height = 384;

	mpointer width = 148;
	mpointer height = 140;
	mpshadow width = 178;
	mpshadow height = 144;

	pxsize = max picture width mtp max picture height plus targa header;

      (maximum files in a self-executable story package, other than the storybook file)

	max package components = 1000;

      (fcpy and fcat: size of data transfer cache for copying and concatenating files)

	sizeof ffun cache = 16384; (units, meaning 64 Kb here)



"variables"

      (following array's rows will be passed to a small loop in the program's initialization
       section to load them, one part per row, from the program's stockfile: in each row, the
       first value gives the offset in the stockfile to read from, which is merely the value
       of the constant that the compiler defines for that filename, using the filename itself;
       the second value is the pointer of the workspace memory area where to the file contents
       must be loaded, and will become [block pointer] in the corresponding <read> operation;
       the third value is the size in bytes of the file constituting that graphic element, also
       defined by the compiler. Such an apparent complication allows to shorten, both visually
       and in terms of code size, the program's initialization section following "programme":
       it's technically more elegant than having a bunch of isocalls, with slightly different
       arguments, one after the other. The array terminates with "minus 1", indicating there's
       no further graphics parts to load...)

  array gfx parts table =	pushcurs;	lz push cursor shape;	size of pushcurs;
				whatcurs;	lz what cursor shape;	size of whatcurs;
				crescent;	text cursor shape;	size of crescent;
				trecrisp;	resident font;		size of trecrisp;
				version;	version shape;		size of version;
				minus 1;

      (storybook's default title string, and default program window's title)

	default title string = { Welcome_To_HSP_Narrator };

      (program's caption when minimized)

	short title string = { HSP_Narrator };

      (will be tied to the menu button, as the label written over it: dots are just stylish)

	my menu caption = { .options. };

      (the program's menu layout)

	menu layout = { menu_[f10] };

	01000000h; option type file selector;	{ <Play_story };	play story;
	02000000h; option type submenu; 	{ <Packaging }; 	null;
	02010000h; option type file selector;	{  <Save_PhotoLZ };	save photolz;
	02020000h; option type file selector;	{  <Package_story };	package story;
	03000000h; option type normal;		{ _Story_credits };	show story credits;
	04000000h; option type normal;		{ _About... };		show credits;
	05000000h; option type normal;		{ _Quit };		quit program;

	endofmenu;

      (the program's reduced menu layout for when this program is used to self-extract
       a pre-packaged storybook: it only plays that story, and doesn't allow packaging;
       well, this is of course not supposed to keep the player from knowing about the
       program as an authoring system, but packaging wouldn't work from already-packaged
       versions of this executable, anyway... informations about downloading the "clean"
       version of the program is given in the credits under the "About..." option)

	package menu layout = { menu_[f10] };

	01000000h; option type normal;		{ Story_credits };	show story credits;
	02000000h; option type normal;		{ About... };		show credits;
	03000000h; option type normal;		{ Quit };		quit program;

	endofmenu;

      (loader/parser error messages)

      make: compact strings;

	out of memory		= { not_enough_memory_to_run_this_storybook }; 7fh;
	no text expected here	= { no_text_expected_here }; 7fh;
	invalid character	= { invalid_character }; 7fh;
	misplaced cookie	= { misplaced_cookie }; 7fh;
	superfluous cookie	= { superfluous_cookie }; 7fh;
	misplaced negation	= { misplaced_negation }; 7fh;
	misplaced conjunction	= { misplaced_conjunction }; 7fh;
	misplaced disjunction	= { misplaced_disjunction }; 7fh;
	misplaced keyword	= { misplaced_keyword }; 7fh;
	void symbol name	= { void_symbol_name }; 7fh;
	extra chrs before spec	= { extra_characters_before_special_variable }; 7fh;
	misplaced operator	= { misplaced_logical_operator }; 7fh;
	misplaced bookmark	= { bookmark_not_allowed_in_structural_block }; 7fh;
	parser interrupted	= { parser_interrupted_by_user_request! }; 7fh;

      (dialog box to select Photolizzie vectorialization method: color, monochrome, sepia)

      make: compact strings;

	plz method select = {

		Please_select_Photolizzie_vectorialization_method:\cr\lf
		\lf
		color:_64_levels_for_red_and_green,_32_levels_for_blue;\cr\lf
		monochrome:_64_shades_of_grey_-_average_of_3_channels;\cr\lf
		sepia:_32_levels_of_sepia_shades_and_noise_rendering.\cr\lf
		\lf
		Color_compresses_worse,_mono_is_better,_sepia_gives_tiny_files.\cr\lf
		\lf
		Tip:_normally,_you_will_want_to_use_color_images_for_ambients'\cr\lf
		panoramics,_and_then_integrate_them_with_detail_shots_in_sepia.

	};

	{ color      }; 1;
	{ monochrome }; 2;
	{ sepia      }; 3;
	{ cancel     }; null;

	null;

	7fh;

      make: units;

	(1) lztga select color;
	(2) lztga select monochrome;
	(3) lztga select sepia;

      (notice box, showed while compressing picture files...)

      make: compact strings;

	saving plz = { Creating_photolizzie_compressed_file... }; null; 7fh;

      (PLZ encoder error messages table - error code 8 means success, no error)

      make: units;

	lztga error table = lztga code 0;
			    lztga code 1;
			    lztga code 2;
			    lztga code 3;
			    lztga code 4;
			    lztga code 5;
			    lztga code 6;
			    lztga code 7;
			    lztga code 8;

      make: compact strings;

	lztga code 0 = { CAN'T_ACCESS_IMAGE_FILE };			{ close }; 0; 0; 7fh;
	lztga code 1 = { NO_MEMORY_FOR_ENCODER_BUFFER };		{ close }; 0; 0; 7fh;
	lztga code 2 = { CAN'T_READ_FROM_IMAGE_FILE };			{ close }; 0; 0; 7fh;
	lztga code 3 = { NEED_FINAL_".tga"_EXTENSION,_IN_LOWERCASE };	{ close }; 0; 0; 7fh;
	lztga code 4 = { INVALID_TGA_FILE_(TOO_LARGE_IF_>_512x384) };	{ close }; 0; 0; 7fh;
	lztga code 5 = { COMPRESSED_DATA_LONGER_THAN_SOURCE!_(RARE) };	{ close }; 0; 0; 7fh;
	lztga code 6 = { FAILED_TO_WRITE_COMPRESSED_FILE };		{ close }; 0; 0; 7fh;
	lztga code 7 = { FAILED_TO_TRUNCATE_COMPRESSED_FILE };		{ close }; 0; 0; 7fh;
	lztga code 8 = { SUCCESSFULLY_SAVED: }; { S/ }; 1; 2; 72;	{ close }; 0; 0; 7fh;

      make: units;

	(1) vector selected file name;
	(2) 256;

      (notice box, showed while packaging storybooks...)

      make: compact strings;

	packaging = { Creating_executable_story_package... }; null; 7fh;

      (packager error messages table)

      make: units;

	pkg error table = pkg code 0;
			  pkg code 1;
			  pkg code 2;
			  pkg code 3;
			  pkg code 4;
			  pkg code 5;
			  pkg code 6;
			  pkg code 7;
			  pkg code 8;
			  pkg code 9;
			  pkg code 10;
			  pkg code 11;
			  pkg code 12;
			  pkg code 13;
			  pkg code 14;
			  pkg code 15;

      make: compact strings;

	pkg code 0 = { CANT_ACCESS_CORE_EXECUTABLE }; { S/ }; 1; 2; 72; { close }; 0; 0; 7fh;

      make: units;

	(1) this narrator executable;
	(2) 256;

      make: compact strings;

	pkg code 1 = { OUT_OF_MEMORY_READING_CORE_EXECUTABLE }; 	{ close }; 0; 0; 7fh;
	pkg code 2 = { CAN'T_READ_CORE_EXECUTABLE };			{ close }; 0; 0; 7fh;
	pkg code 3 = { CAN'T_FIND_DEFSTORY_MARKER };			{ close }; 0; 0; 7fh;
	pkg code 4 = { INVALID_STORYBOOK_FILE_NAME }; { S/ }; 1; 2; 72; { close }; 0; 0; 7fh;

      make: units;

	(1) vector selected file name;
	(2) 256;

      make: compact strings;

	pkg code 5 = { CAN'T_ACCESS_STORYBOOK_FILE }; { S/ }; 1; 2; 72; { close }; 0; 0; 7fh;

      make: units;

	(1) vector selected file name;
	(2) 256;

      make: compact strings;

	pkg code 6 = { CAN'T_READ_STORYBOOK_FILE };			{ close }; 0; 0; 7fh;
	pkg code 7 = { OUT_OF_MEMORY_COMPRESSING_STORYBOOK };		{ close }; 0; 0; 7fh;
	pkg code 8 = { FAILED_TO_COMPRESS_STORYBOOK };			{ close }; 0; 0; 7fh;
	pkg code 9 = { CAN'T_WRITE_PACKAGE_FILE }; { S/ }; 1; 2; 72;	{ close }; 0; 0; 7fh;

      make: units;

	(1) package file name;
	(2) 256;

      make: compact strings;

	pkg code 10 = { CAN'T_TRUNCATE_PACKAGE_FILE };			{ close }; 0; 0; 7fh;
	pkg code 11 = { CAN'T_ACCESS_COMPONENT }; { S/ }; 1; 2; 72;	{ close }; 0; 0; 7fh;

      make: units;

	(1) package pictures folder name;
	(2) 256;

      make: compact strings;

	pkg code 12 = { TOO_MANY_COMPONENT_FILES };			{ close }; 0; 0; 7fh;
	pkg code 13 = { FAILED_TO_COMPRESS_COMPONENTS_TABLE };		{ close }; 0; 0; 7fh;
	pkg code 14 = { CAN'T_WRITE_COMPONENTS_TABLE }; 		{ close }; 0; 0; 7fh;
	pkg code 15 = { CAN'T_LINK_COMPONENT }; { S/ }; 1; 2; 72;	{ close }; 0; 0; 7fh;

      make: units;

	(1) package pictures folder name;
	(2) 256;

      (dialog box communicating that a storybook has been packaged without problems,
       and indicating path and name of the newly created executable file...)

      make: compact strings;

	packaged successfully = {

		Successfully_packaged_self-executable_story!\cr\lf
		\lf
		Selected_story_has_been_compressed_and_linked_to_this_version\cr\lf
		of_the_HSP_Narrator._This_might_result_in_three_advantages:\cr\lf
		\lf
		1)_packaged_stories_take_less_disk_space;\cr\lf
		2)_they_are_formed_by_a_single_executable_file;\cr\lf
		3)_they_are_much_more_difficult_to_spoil,_because_their\cr\lf
		___storybook_file_is_compressed,_other_than_being_part\cr\lf
		___of_an_executable_file.\cr\lf
		\lf
		But_mostly_notice_point_2:_your_story's_players_will_not_need\cr\lf
		this_program_to_play_your_packaged_storybook._Also,_if_you've\cr\lf
		used_pictures_in_your_book,_they_won't_need_that_folder_where\cr\lf
		you're_holding_pictures._All_they_need_is_the_following_file:

	};

	{ S/ }; 1; 2; 72;
	{ continue }; null;

	null;

	7fh;

      make: units;

	(1) package file name;
	(2) 256;

      (dialog box with this program's credits: "me, me, and only me". Meh!)

      make: compact strings;

	credits = {

		______________This_Story_Is_Powered_by_The_Narrator!\cr\lf
		______________________(HSP_Narrator_v_5.6.4)\cr\lf
		\lf
		The_Narrator:_Copyright_1999-2005,_written_by_Alessandro_Ghignola\cr\lf
		The_Narrator:_Copyright_1999-2005,_Home_Sweet_Pixel_software\cr\lf
		\lf
		Narrator_is_open-source,_and_freely_distributable_under_GNU_LGPL:\cr\lf
		see_"How_to_use_The_Narrator"_for_license_informations;_however,\cr\lf
		the_story_you_are_playing_may_be_under_a_different_license_-_use\cr\lf
		menu_option_"Story_credits"_for_informations_about_the_story.\cr\lf
		\lf
		The_Narrator_powered_by_the_L.in.oleum_virtual_machine,_v1.14.\cr\lf
		This_version_last_compiled_on:_June_4th,_2005.\cr\lf
		\lf
		Author's_home_site_is_reachable_via_the_following_domains:\cr\lf
		http://anywhere.i.am,_http://anywherebb.com,_http://0x44.com\cr\lf
		\lf
		To_contact_Alex_submit_a_form_at:_http://0x44.com/tellalex.html\cr\lf
		This_program's_download_page_is_at:_http://0x44.com/software.html

	};

	{ continue };				null;
	{ home_site };				1;
	{ contact_author };			2;
	{ download_this_authoring_system };	3;

	null;

	7fh;

      make: units;

	(1) anywhere i am;
	(2) tell alex;
	(3) download narrator;

      (credit URLs to be handled by the system's default browser, when executed)

      make: compact strings;

	site link	= { http://anywherebb.com		}; 7fh;
	contact link	= { http://anywherebb.com/tellalex.html }; 7fh;
	download link	= { http://anywherebb.com/software.html }; 7fh;

      (hard-wired filenames and path accessories: to contemplate execution of this program
       from a Linux binary, where file names would be case-sensitive, the following rules
       must be defined also for storybook components:
       - this program is originally called "The Narrator.exe", with a lowercase extension;
       - all the rest of files and extensions must be strictly lowercase.)

      make: units;

	narrator executable	= { The_Narrator.exe	};
	stories extension	= { .txt		};
	situations extension	= { .inf		};
	pictures folder 	= { \usfiles		};
	tga extension		= { .tga		};
	exe extension		= { .exe		};
	plz extension		= { .plz		};
	path slash		= { /			};

      (credits triggering answer: automatically filled in player input line upon choosing
       the "Story credits" option from the menu; ideally, all storybook files might react
       to this sentence with an "IF show story credits...FI" block of commands somewhere)

      make: compact strings;

	credits trigger = { show_story_credits }; 7fh;

      (default storybook file name: Narrator will look for it before an effective storybook
       is loaded via the "Play story" option; however, when the program is used to execute
       a packaged story, which is linked to the program, this file will not be fetched)

      make: units;

	default storybook file = { default.txt };
	default storybook situation file = { default.inf };

      (storybook file name, and its corresponding "savegame", the "situation file name", are
       both indicated by two pointers leading to their strings, rather than being strings on
       themselves: that's because the storybook can be a real file, played via "Play story",
       or a packaged story, or the defaut story. In the last two cases, there is no filename
       for itself, because packaged stories and the default story are linked to The Narrator
       as parts of its stockfile, so these pointers allow to easily distinguish those cases:
       when the story is loaded from the stockfile, the pointer is set to null; incidentally
       this is also the way the L.in.oleum virtual machine indicates the stockfile, when the
       filename string pointer gets loaded into [file name]... when, instead, the pointer to
       the situation file is null, the situation file isn't saved; to recap, it may be:
       - the default one, indicated by a pointer to the above string, and that's on startup;
       - an effective story savegame, indicated by a pointer to "storybook situation file";
       - zero, when the story is stockfile's "defstory.txt" and no valid storybook is found.)

	pointer to storybook file name = default storybook file;
	pointer to situation file name = default storybook situation file;

      (photolizzie rendering RGB channels loss compensation: normally it's 3 for red and green,
       and 7 for blue, because that's the missing span resulting from the reduction of original
       8-bit truecolor levels to 6 bits for red and green, and 5 for blue; compensation is zero
       when rendering in "sepia" mode, where compensation is replaced by randomic noise...)

	lztga loss compensation = 3;
	lztga blue compensation = 7;

      (size of a tabulation in a storybook file: this is variable for possible indication of an
       alternative value within the storybook itself; normally, tabs are 8 chars in editors...)

	ls tab size = 8;

      (remaining snippets... for which you'd better check the notes in the "programme" period)

      make: compact strings;

	load error title = { LOAD_ERROR }; 7fh;
	package files path = { \usfiles/ }; 7fh;

      make: units;

	load error display pattern = report; 97; say; 59; 95; report; 98; claim; 95; null;
	load error display pattern size marker = undefined *** zero;



"workspace"

      (workspace memory map: consider that by convention, the L.in.oleum virtual machine sets
       all the locations of this map to zero, upon allocating memory for the following things)

	known display width		= 1;	(see "display cleanup" and "display refresh")
	known display height		= 1;	(see "display cleanup" and "display refresh")

	eraser bounds			= 4;	(rect. area to erase words after word-wrapping)
	cursor line			= 4;	(rect. area to update the cursor line)

	storybook file size		= 1;	(size of loaded storybook file in bytes)
	storybook file checksum 	= 1;	(a hash of storybook's displayed contents)
	storybook file position 	= 1;	(position to start reading storybook file from)
	valid storybook file		= 1;	(flag: becomes true when @+STORY cookie found)
	formerly spaced out		= 1;	("load storybook": flag to remove extra blanks)

	pns return			= 1;	(tell "play new story" to return to main flow)

      (savegame file header: three adjacent memory units to be saved as a block of 12 bytes)

	situation file header		= 1;	(+0 storybook file contents checksum)
	number of symbols		= 1;	(+1 number of symbols defined in storybook)
	session number			= 1;	(+2 session number, progressive moves counter)

      (when loading a situation file, if the storybook has been modified in the meantime, ie.
       during its "developement" by its author, the checksum will be checked and, since it
       might not match the former checksum saved in the situation file, there might be more
       or less symbols, or some symbols may not be found and registered in the same order as
       before, due to the author possibly moving code around... so, the following variable
       will backup [number of symbols] before reading the above savegame header: if situation
       file checksum doesn't match, meaning something has changed in the storybook since last
       situation was saved, the former situation file will not be loaded, and instead deleted
       to make room for the next, updated situation file...)

	previous number of symbols	= 1;	(backup while loading a situation file)

      (variables used while loading and parsing storybooks)

	ls column			= 1;	(column of currently parsed character)
	ls row				= 1;	(row of currently parsed character)
	rest of control block now	= 1;	(bytes to skip after keyword identificator)
	open symbol			= 1;	(is it parsing throught a symbol name?)
	open assignment 		= 1;	(is it parsing throught a NOW... clause?)
	open condition			= 1;	(is it parsing throught a condition check?)
	open jump			= 1;	(parsing after ACTUALLY... TO... or PLEASE...?)
	open push			= 1;	(is it parsing after a PUSH...TO was opened?)
	feat push			= 1;	(is it parsing after INDICATE...TO was opened?)
	open claim			= 1;	(is it parsing throught a CLAIM... statement?)
	open report			= 1;	(is it parsing after a REPORT instruction?)
	open seeding			= 1;	(is it parsing after a SEED instruction?)
	statement type			= 1;	(keyword identificator of last found statement)
	significant text seen		= 1;	(used in checks for parts where no text can be)
	disallow text			= 1;	(used along with the above, for those checks)
	message 			= 1;	(ptr. to error message string for "load error")

      (the loader will identify and register symbols, ie. "clauses" and "bookmarks", as soon
       as it spots them into the storybook; bookmarks will always have undefined status, but
       clauses will all be registered as false. Later, the parser will correct their status,
       if it's the case, upon finding a NOW clause which is not denied by a "NOT" operator...)

	symbol code			= 1;	(current symbol code / code of symbol to find)
	symbol type			= 1;	(future symbol type, while being registered)
	symbol status			= 1;	(current symbol status: false on registration)

      (variables used while parsing storybooks:
       - jumps of type "actually" are simple GOTO statements, modifying the pointer to the next
	 instruction of the storybook; jumps of type "please" are subroutine calls, or GOSUBs,
	 where the actual instruction's pointer is put on an internal "stack" for subsequently
	 returning to it, ie. when a DONE instruction is found; jumps of type "to" are the same
	 as "please" calls, but are performed in consequence of a click on a pushable area, ie.
	 on a hyperlink defined by a PUSH...TO block, and they will behave as "please", needing
	 to be distinguished anyway because at the end of the subroutine they will trigger the
	 parsing of the whole storybook file from its beginning, as if they were "moves"...)

	caret x 			= 1;	(text cursor's actual X coordinate)
	caret y 			= 1;	(text cursor's actual Y coordinate)
	caret x before last word	= 1;	(cr. X before last word was written [wordwrap])
	pointer to last word		= 1;	(for rewriting it on the next line [wordwrap])
	caret x before split		= 1;	(text cursor's starting X of splitted area)
	caret y before split		= 1;	(text cursor's starting Y of splitted area)
	negation			= 1;	(flag: true if a "NOT" was found in condition)
	condition status		= 1;	(flag: general condition status, true or false)
	last true level 		= 1;	(highest nidification level that resulted true)
	numeric value			= 1;	(numeric values' parser integer accumulator)
	condition type			= 1;	("IF" or "EVERY": "EVERY" is a particular "IF")
	saying something		= 1;	(true when sending text to the display: SAY...)
	jump type			= 1;	(can be "actually", "please", or "to")
	condition length		= 1;	(counts characters in IF... conditions strings)
	words in condition		= 1;	(counts words found within a condition string)
	percent found in condition	= 1;	(signals percentage-based randomized condition)
	concrete new word		= 1;	(used while scanning cond. strings for words)
	previous word pointer		= 1;	(same as above, remembers where a word started)
	confirmed words 		= 1;	(counts word-matches between conds. and answer)
	push starting point		= 1;	(taken as caret position upon meeting PUSH...)
	push ending point		= 1;	(taken as caret position upon meeting ...TO...)
	leftside negation		= 1;	(infos on left operand when A/L operator found)
	leftside symbol code		= 1;	(infos on left operand when A/L operator found)
	leftside numeric value		= 1;	(infos on left operand when A/L operator found)
	operator			= 1;	(type of A/L operator met: <, =, >)
	operation			= 1;	(calculation to do: addition, division...)
	ps auxiliary			= 1;	(left-side operand value in calculations)
	ps aux offset			= 1;	(left-side symbol record's offset in calcs.)

      (variables used by the application's control loop, where user input is detected,
       and outputs are given...)

	text cursor x			= 1;	(X position of text cursor in answer's line)
	text cursor y			= 1;	(Y position of text cursor in answer's line)
	what cursor x			= 1;	(future placement of "unknown answer pointer")
	what cursor y			= 1;	(future placement of "unknown answer pointer")
	what cursor active		= 1;	(signals "unknown answer pointer" is in show)
	answer length			= 1;	(offset of null term. in player answer string)
	answer numeric value		= 1;	(as computed by "parse players answer")
	words in answer 		= 1;	(as computed by "parse players answer")
	answer rejected 		= 1;	("no" if a condition matches, "yes" otherwise)
	update only vicinity of cursor	= 1;	(typically, while editing the answer's line)
	pushing area			= 1;	(flag to determine when player releases click)

      (current displayed picture metrics:
       flag [will append], when true, witnesses right-side alignment of picture)

	will append			= 1;
	storybook picture left		= 1;
	storybook picture width 	= 1;
	storybook picture top		= 1;
	storybook picture bottom	= 1;

      (variables used by PLZ image encoder/decoder)

	lztga buffer			= 1;	(pointer to dynamically allocated TGA buffer)
	lztga buffer size		= 1;	(size of above buffer in units)

	lztga save colors		= 1;	(flag: true if color mode, false = monochrome)
	lztga save sepias		= 1;	(flag: when monochrome, true if sepia mode)

	plane pixels			= 1;	(pixels in image plane / total pixels in image)
	plane bits			= 1;	(bits in single plane: planes being R, G and B)
	rewind bits			= 1;	(bits to go back to next pixel of next plane)
	lv red				= 1;	(work variable holding current red intensity)
	lv green			= 1;	(work variable holding current green intensity)
	lv blue 			= 1;	(work variable holding current blue intensity)
	plane rewind			= 1;	(bytes to go back to next pixel of next plane)
	pb offset in target		= 1;	(offset to curr. "top of data", while encoding)
	plane pixels to do		= 1;	(pixels counter to end encoding/decoding loops)
	lplz draw picture		= 1;	(on load, true=trace image, false=decode only)

      (variables used while reading and writing packaged storybooks:
       note the executable file size is found by scanning the binary executable until a certain
       occurrence of the @STORY cookie is detected; @STORY appears, encoded in the binary, for
       a certain number of times, depending on how many times it's compared, in the code, with
       registers and variables. Only the very last occurrence of @STORY is the one marking the
       beginning of the "build/defstory.txt" file, which is where packaged storybooks must join
       the copy of The Narrator's executable file, indicated by [narrator executable size])

	narrator executable size	= 1;	(byte size of this program, until "defstory")
	occurrences to do		= 1;	(occurrences of @STORY to skip in binary file)
	units to do			= 1;	(units to scan, length of "The Narrator.exe")
	pkg block			= 1;	(pointer to dynamically allocated package buf.)
	pkg block size			= 1;	(size of above buffer in units)
	pkg storybook			= 1;	(pointer to storybook area in package block)
	pkg storybook block size	= 1;	(size of above area in units)
	pkg storybook size		= 1;	(storybook file size, first uncomp, then comp.)

	pkg file command		= 1;	(toggled with "get first file"/"get next file")
	components table records	= 1;	(number of records in components table)
	components table record pointer = 1;	(ptr. to unit where to store the next record)
	components table file offset	= 1;	(actual offset relative to base of pkg. table)
	components table file symbol	= 1;	(actual file name hash for the record)

	packaged storybook present	= 1;	(reading packaged storybook, confirms validity)
	packaged components base offset = 1;	(base of pkg. table reading packaged storybook)

      (string functions)

	source string			= 1;	(pointer to source string)
	target string			= 1;	(pointer to destination string)
	string length			= 1;	(units or bytes in source string)

      (fcpy and fcat)

	source file			= 1;	(pointer to source file's name string)
	source fpos			= 1;	(byte from which starting reading)
	target file			= 1;	(pointer to target file's name string)
	target fpos			= 1;	(byte from which starting writing)
	transf size			= 1;	(size of transfer, full file if negative)
	fcpy verify			= 1;	(internal counter - for writes verify)
	fcpy callback			= 1;	(callback parser, unused here)

      (vectors and arrays: configuration's global k buffer - from/to the system registry)

	configuration k 		= 255;

      (vectors and arrays: TGA/PLZ storybook and accessory pictures; such loads happen often
       enough to justify the fact that these buffers are static, and not dynamically allocated:
       memory allocation by a resize of the application's workspace takes some time...)

	graphics decompression layer	= pxsize;
	graphics vectorialization layer = pxsize;
	picture layer			= pxsize;

      (vectors and array: additional video layers
       note - The Narrator adds a "canvas layer", which, along with iGUI's "backdrop layer"
       and "primary display", setups a triple buffering mechanism; this is done to save the
       program from having to re-parse the whole storybook in order to retrace the display,
       when no user move is performed but, for example, the backdrop must be retraced due to
       pulldown menus and/or dialog boxes going away, or to the text cursor being moved...
       then, there's the reference layer, which only provides one pixel for every text line,
       where a map of pushable areas' destination addresses is held: of course the reference
       layer isn't used for visual output, it's only for quick PUSH...TO links management...)

	canvas layer			= constant width mtp constant height;
	reference layer 		= constant width mtp maximum lines;

      (vectors and arrays: mouse cursors graphics
       note - "lz" versions are photolizzied parts, as included in the stockfile;
       then there are three buffers for three different aspects of the mouse pointer,
       but only one buffer for the shadow's image: that's because the pointers may change,
       but their shadow is supposed to be quite compatible with all their three versions)

	lz push cursor shape		= size of pushcurs asbytesize;
	lz what cursor shape		= size of whatcurs asbytesize;

	norm cursor shape		= mpointer width mtp mpointer height plus targa header;
	push cursor shape		= mpointer width mtp mpointer height plus targa header;
	what cursor shape		= mpointer width mtp mpointer height plus targa header;
	feat cursor shadow		= mpshadow width mtp mpshadow height plus targa header;

      (the text cursor is only loaded here from the stockfile, never kept in an uncompressed
       version inside a separate buffer: it's a small piece of graphics, and it's not retraced
       as frequently as a mouse cursor, so I'm saving some memory here by tolerating the small
       overhead due to the repeated decompression of this buffer when the cursor is retraced)

	text cursor shape		= size of crescent asbytesize;

      (the font is fixed-size to avoid bothering for correcting its metrics, although its
       characters are proportional: it's loaded inside an off-screen video layer of exactly
       256 by 152 pixels, at one unit per pixel, and its pixels are directly accessible by
       the tgafont library for fast tracement of characters' shapes)

	resident font			= size of trecrisp asbytesize;
	resident font block		= 256 multiplied 152;

      (the "version" snippet is the thing shown in the lower-right corner: mostly decorative;
       like the text cursor, it's small and to be retraced only rarely, and more specifically
       it gets retraced on the canvas layer before the storybook is parsed after a player's
       "move", so it's got no uncompressed ready-to-use version...)

	version shape			= size of version asbytesize;

      (vectors and arrays: 256-character file name buffers)

	storybook situation file	= 256;
	storybook picture file		= 256;
	this narrator executable	= 256;
	package base file name		= 256;
	package file name		= 256;
	package pictures folder name	= 256;
	component file name		= 256;

      (vectors and arrays: storybook title string)

	current title			= 256;

      (vectors and arrays: storybook symbols table)

	symbols code			= max number of symbols;
	symbols type			= max number of symbols;
	symbols status			= max number of symbols;

      (vectors and arrays: storybook runtime stack)

	return addresses		= max please calls;
	conditional levels		= max please calls;

      (vectors and arrays: player answer buffers)

	answer buffer			= max characters in answer plus 1;
	answer backup buffer		= max characters in answer plus 1;
	answer word pointers		= max characters in answer plus 1;

      (vectors and arrays: condition strings to compare against player answers)

	condition contents		= max characters in condition plus 1;
	condition word pointers 	= max characters in condition div 2 plus 1;

      (vectors and arrays: storybook package components table)

	package components table	= 2 mtp max package components;
	compressed components table	= 2 mtp max package components;

      (vectors and arrays: fcpy/fcat data transfer buffer)

	ffun cache = sizeof ffun cache;

      (vectors and arrays: static ASCII buffer for storybook file contents
       this is where the storybook file is read, and holds the 8-bit-per-character version of
       the file as it was on the disk - for faster and more comfortable parsing, it's encoded
       by the "load storybook" subroutine, which expands it into "storybook symbolic contents")

	storybook ascii contents	= max storybook size asbytesize;

      (storybook's loaded contents buffer, which is dynamically allocated: the following
       label is the last of the wordspace because it will be dynamically extended: upon
       loading a storybook, the loader will increase [ramtop] by as many units as needed:
       the size of the storybook's loaded-up version is given by the byte size of its ASCII
       file, minus the extra characters forming keywords after the very first character of
       each keyword found in the file, because keywords are stored in the following future
       buffer as single units, and not as fourbyte strings: see the loader to understand
       how this works... on startup, this buffer is given a fixed size that's enough for at
       least holding an error message of upto 100 characters)

	storybook symbolic contents = pragma load error display pattern size marker
				      minus load error display pattern plus 100;



"programme"

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			       INITIALIZATION, MAIN PROGRAM FLOW
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

      (load up configuration k)

	[global k command] = k read;
	[global k name] = narrator executable;
	[global k data] = configuration k;
	isocall;
      ? failed -> no configuration data found;

      (setup display position and size: it's done here, having previously zeroed the area of
       the display window, to avoid a very little perceivable, but still unelegant, flickering
       effect while the window slides to its recorded position... I've been really picky, here,
       but I can't endure flickerings...)

	[display x position] = [configuration k plus 0];
	[display y position] = [configuration k plus 1];

	[display width] = constant width;
	[display height] = constant height;

	isocall;

	-> configuration data was found;

      (store effective display dimensions as known dimensions: they aren't necessary those
       given above because of desktop area limits in windowed mode; the program DOES start
       in windowed mode, so it will have to watch out for switches to full-screen mode and
       eventually notice the display dimensions have changed, and if yes, refit its window
       contents to the new display size: see "service display refresh" and "display cleanup")

      "no configuration data found"
	[display x position] = middle;
	[display y position] = middle;

	[display width] = constant width;
	[display height] = constant height;

	isocall;

      "configuration data was found"
	[known display width] = [display width];
	[known display height] = [display height];

      (never-changing parameters for TGAfont: most are setup once and forever, but display
       dimensions may suffer from the problems explained in the above comment, so they're
       also re-fitted by "display cleanup")

	[tgat source block] = resident font block;
	[tgat font width] = text font width;
	[tgat font body] = text font body;
	[tgat display alignment] = [display width];
	[tgat display height] = [display height];
	[typeface limits pattern] = A8A8A8h;

      (selecting window captions)

	[window title] = default title string;
	[small caption] = short title string;

      (installing the menu)

	[menu caption] = my menu caption;
	[menu to install] = menu layout;
	=> install menu;

      (before initializing iGUI, which causes a first visualization of the display, and some
       of its contents may be influenced by the following parameter, setup StdFont library to
       place a couple pixels between every line of text, such as in pulldown menus and dialog
       boxes: it makes text lines stand out better, and slightly more readable...)

	[text interlinespacing] = 2;

      (iGUI bootstrap: iGUI is the Graphical User Interface for this application)

	=> initialize integrated gui;

      (load some graphic parts from the stockfile: mouse pointers, text cursor, the font...)

	a = array gfx parts table;

      "i load next part"
	[file command] = read;
	[file name] = stockfile;
	[file position] = [a];
	[block pointer] = [a plus 1];
	[block size] = [a plus 2];
	isocall;
	a + 3;
      ? [a] != minus 1 -> i load next part;

      (the following code sets up some preliminary arguments to subroutine "load photolz"...)

	[lztga loss compensation] = 0;	(due to alpha dim fx: prefere full black to full white)
	[lztga blue compensation] = 0;	(due to alpha dim fx: prefere full black to full white)
	[lplz draw picture] = no;	(load photolz: do not trace pictures - uncompress only)

      (uncompress mouse pointer and its shadow: iGUI will have loaded them throught the call
       to "initialize integrated gui"; however, they are compressed with routines given in this
       particular program, and the iGUI library won't be able to display them correctly unless
       this program unpacks them for it...)

	[tga picture data] = crosshair shape;
	[tga target layer] = norm cursor shape;
	=> load photolz;

	[tga picture data] = crosshair shadow;
	[tga target layer] = feat cursor shadow;
	=> load photolz;

	[pointer to arrow shape] = norm cursor shape;
	[pointer to arrow shadow] = feat cursor shadow;

      ("push cursor" is the version of the mouse pointer shown while hovering a pushable link,
       defined in storybooks as a PUSH...TO text span: the pointer is specific to this program,
       and since the iGUI doesn't load it up on itself, it's read here, and then uncompressed
       to its final buffer, from which the program will be able to select it in place of the
       normal mouse pointer by loading [pointer to arrow shape] with "push cursor shape")

	[tga picture data] = lz push cursor shape;
	[tga target layer] = push cursor shape;
	=> load photolz;

      ("what cursor" is for when one of the player's answers didn't match any conditions in the
       storybook, and The Narrator doesn't react to that answer, but still indicates this fact
       by changing the mouse pointer to this version, also forcing it to move to point at the
       text cursor in the answer prompt: it's loaded and uncompressed exactly as "push cursor")

	[tga picture data] = lz what cursor shape;
	[tga target layer] = what cursor shape;
	=> load photolz;

      (uncompress the memory-resident font: this is a bitmap for the TGAfont library to use,
       and contains the shapes of all characters from ASCII code 32 to 126; they are kept on
       an off-screen graphics block, being an array of 256 by 152 pixels/units, organized in
       rows of 16 shapes each. For an immediate, and deeper, look to how the font is stored,
       the original TGA file is given in the "project clips" folder as "trecrisp.tga". You'll
       notice there's bright magenta markers in that bitmap: they mark the beginning and end
       columns of each character shape, for which you'd better read comments in "gen/TGA.txt")

	[tga picture data] = resident font;
	[tga target layer] = resident font block;
	[tga display alignment] = 256;
	[tga display height] = 152;
	[tga picture left] = zero;
	[tga picture top] = zero;
	[tga effect] = service fx raw;
	[lplz draw picture] = yes;
	=> load photolz;

      (after loading gfx parts that might be subject to "alpha dim" effects, restore channel
       intensity compensation factors for the "load photolz" subroutine to properly load the
       plain normal pictures that may be embedded in the storybook...)

	[lztga loss compensation] = 3;
	[lztga blue compensation] = 7;

      (mouse pointer metrics and other adjustments to some iGUI parameters)

	[arrow region width] = mpointer width;
	[arrow region height] = mpointer height;
	[arrow shadow region width] = mpshadow width;
	[arrow shadow region height] = mpshadow height;
	[arrow hot spot x] = 7;
	[arrow hot spot y] = 2;
	[horizontal arrow shadow drift] = 0;
	[vertical arrow shadow drift] = 0;
	[arrow altitude over background] = greatest signed integer;
	[balloon relative x position] = 10;
	[balloon relative y position] = 88;
	[arrow shape effect] = service fx alpha dim;
	[file selector width] = 300;

      (feeding initial random seed to the Mersenne Twister, basing on game's epoch)

	=> get epoch;
	[rnd seed] = e;
	=> set random seed;

      (selecting window retrace handler and window control handler)

	[work area manager] = service display refresh;
	[control loop] = service story control loop;

      (look for a packaged storybook, which may have been compressed and linked to this
       executable file: if you find it, check if it holds a valid @STORY cookie; if you
       can't find a packaged storybook, try to load it from file "default.txt"; if you
       did find a packaged storybook, but no @STORY cookie within it, assume the package
       got in some way corrupted, and truncate execution...)

	=> load packaged storybook;

      ? [packaged storybook present] = no -> load storybook from file;
      ? [valid storybook file] = yes -> go on with the story;

	end; (package corrupted)

      (looking for a filename given as the command line argument: trimming any ASCII codes
       below or equal to 32, or equal to 34 to also trim eventual doublequotes, copy command
       line arguments string as a file name of a upto 255 characters to "vector selected file
       name": that's also the buffer in which iGUI file selectors return names, and it's
       chosen as this operation's destination buffer because it allows, once filled, to simply
       call "play new story", simulating selection from the "play story" option...)

      "load storybook from file"
	a = commandline;

      "clparsefromstart"
      ? [a] = null -> no cmdline filename;
      ? [a] <= 32 -> clstrim;
      ? [a] != 34 -> clfoundstart;
      "clstrim"
	a +;
	-> clparsefromstart;

      "clfoundstart"
	b = commandline plus 255;

      "clparsefromend"
      ? [b] <= 32 -> cletrim;
      ? [b] != 34 -> clfoundend;
      "cletrim"
	b -;
	-> clparsefromend;

      "clfoundend"
	c = vector selected file name;

      "clcopy"
	[c] = [a];
	a +;
	c +;
      ? a <= b -> clcopy;

	[c] = null;

      (if there's something significant in the command line, ie. if "vector selected file name"
       isn't a void string, try to load the storybook from an intended filename matching that
       string, else proceed to load from "default.txt", whose filename's pointer is already
       loaded in variable [pointer to storybook file name]...)

      ? [vector selected file name] = null -> no cmdline filename;

      (flag [pns return], set to true, informs "play new story" to return without branching to
       "service main loop", as it would do when called throught menu option "play story": that's
       because the iGUI hasn't been "entered" as a subroutine yet, while this is necessary to
       ensure the iGUI proper control of the application, and store the correct return address
       for quitting the program's main flow - see comments before label "go on with the story"
       for further details...)

	[pns return] = true;
	=> play new story;
	-> go on with the story;

      (loading either the command-line-given filename, or "default.txt":
       if not found, or if invalid, load "build/defstory.txt" from your stockfile...)

      "no cmdline filename"
	=> load storybook;

      ? [valid storybook file] = yes -> go on with the story;

	[number of symbols] = zero;
	[storybook file size] = zero;
	[pointer to situation file name] = null;
	[pointer to storybook file name] = null;
	[storybook file position] = defstory;
	=> load storybook;

      ? [valid storybook file] = yes -> go on with the story;

	end; (defstory corrupted)

      (if you have a working storybook, even defstory.txt in the worst case, load its
       situation file - but there will be none for defstory.txt - then parse it once,
       by calling "service main loop", to build the initial contents of canvas layer:
       finally, transfer control to the iGUI, and when the iGUI returns control here,
       it means the user chosen to quit the program - thus, the storybook's situation
       will be saved to provide continuity with the next time that story is run - ps.
       there are three ways to quit the program: via ALT+F4 checked as a conventional
       iGUI's keyboard shortcut; via the last menu option, and via clicking the upper
       left button of the program's window...)

      "go on with the story"
	=> load situation;
	=> service main loop;
	=> enter integrated gui;
	=> save situation; (always, before quitting)

      (save configuration k: actually, it only must hold the window's coordinates, but they are
       effectively saved only if the program isn't running fullscreen, to avoid zeroing them in
       such cases...)

      ? [display status] + exclusive -> no position save;

	[configuration k plus 0] = [display x position];
	[configuration k plus 1] = [display y position];

	[global k command] = k write;
	[global k name] = narrator executable;
	[global k data] = configuration k;
	isocall;

      "no position save"
	end; (natural end of main program flow)

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				       PHOTOLIZZIE ENCODER
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

      (popup menu's file selector hook: setup iGUI's file selector to list .tga files)

      "save photolz"
	[file selector filter] = tga extension;
	[on file select] = service save photolz;
	end;

      (upon choosing the name of the .tga file to save as .plz, present a dialog box to choose
       the rendering method: photolizzie pictures can be rendered in 6:6:5 truecolor, with 32
       levels for blue and 64 for red and green, in 64 shades of grey begin the "monochrome"
       option, or in 32 shades of sepia, with 5 bits per pixel; sepia produces very small files
       because of the great redundancy of pixel intensities - which are then reduced by the
       variable LZ/LZ77 compressor provided by the "lz" library: because 32 levels are often
       too few to provide decent rendering of smooth gradients in photographs, sepia rendering
       adds some uniform noise to each pixel, at the same time simulating an "old" photo...)

      "service save photolz"
	[question datascript] = plz method select;
	-> csquestion;

      (this routine is entered when the user clicks "color" in the above dialog box)

      "lztga select color"
	[lztga save colors] = yes;
	-> lztga begin;

      (this routine is entered when the user clicks "sepia" in the above dialog box)

      "lztga select sepia"
	[lztga save colors] = no;
	[lztga save sepias] = yes;
	-> lztga begin;

      (this routine is entered when the user clicks "monochrome" in the above dialog box)

      "lztga select monochrome"
	[lztga save colors] = no;
	[lztga save sepias] = no;

      (begin processing tga-to-plz conversion: while you work, display a temporary notice)

      "lztga begin"
	[question datascript] = saving plz;
	=> csnotice;

      (ok, set [lztga buffer] to null: that's a pointer to a dynamically-allocated memory
       area that will temporarily hold the picture file to convert; when it's null, and
       if it isn't, later, assigned to a non-null value because memory allocation fails,
       the null pointer signals that there's no memory block to free...)

	[lztga buffer] = null;

      (set error phase counter, as register E, to zero)

	e # e;	(0 -- can't access image file)

      (see if the tga file to convert exists, and retrieve its size)

	[file command] = test;
	[file name] = vector selected file name;
	isocall;
      ? failed -> lztga error;

	e +;	(1 -- no memory for encoder buffer)

      (calculate buffer size and allocate buffer)

	[lztga buffer size] = [file size];
	[lztga buffer size] > 2;
	[lztga buffer size] +;
	[lztga buffer] = [ramtop];
	[ramtop] + [lztga buffer size];
	isocall;
      ? failed -> lztga error;

	e +;	(2 -- can't read from image file)

      (read TGA file into newly allocated buffer)

	[file command] = read;
	[file name] = vector selected file name;
	[file position] = zero;
	[block pointer] = [lztga buffer];
	[block size] = [file size];
	isocall;
      ? failed -> lztga error;

	e +;	(3 -- need final ".tga" extension, in lowercase)

      (find ".tga" file extension: must be final extension, and lowercase)

	[source string] = vector selected file name;
	[target string] = tga extension;
	=> strstr;
      ? failed -> lztga error;
	a = [target string];
      ? [a plus 4] != 0 -> lztga error;

      (replace extension with ".plz" for future saving)

	[a plus 1] = 112; (p)
	[a plus 2] = 108; (l)
	[a plus 3] = 122; (z)

      (draw picture offscreen, on "graphics decompression layer")

	[tga picture data] = [lztga buffer];
	[tga target layer] = graphics decompression layer;
	[tga picture left] = zero;
	[tga picture top] = zero;
	[tga effect] = service fx raw;
	[tga display width] = max picture width;
	[tga display height] = max picture height;
	[tga display alignment] = max picture width;
	=> load tga picture;

	e = 4;	(4 -- invalid TGA file, or too large)

      ? failed -> lztga error;
      ? [ltp pixels] > max picture width -> lztga error;
      ? [ltp scanlines] > max picture height -> lztga error;
      ? [ltp colormap size] != zero -> lztga error;
	[plane pixels] = [ltp pixels];
	[plane pixels] * [ltp scanlines];
      ? [plane pixels] < 2 -> lztga error;

      (prepare in and out streams pointers, copy TGA file header as it is)

	[pb stream] = [lztga buffer];
	[pb offset] = zero;
	[bit stream pointer] = graphics vectorialization layer;
	[starting bit number] = zero;
	[bit field size] = 8;

	a = 18;
	a + [ltp id block size];
      "lztga copy header"
	a -->;
	=> get progressive byte;
	[pb offset] +;
	[bit field content] = [pb bvalue];
	=> set bit field;
	[starting bit number] + 8;
	<-- a;
	a ^ lztga copy header;

      (set pixels counter to end encoding loops)

	[plane pixels to do] = [plane pixels];

      (branch to appropriate encoding loop)

      ? [lztga save colors] = yes -> lztga color;

      (monochrome/sepia encoder)

      "lztga monochrome"
	=> get progressive byte;
	[pb offset] +;
	[lv blue] = [pb bvalue];
	=> get progressive byte;
	[pb offset] +;
	[lv blue] + [pb bvalue];
	=> get progressive byte;
	[pb offset] +;
	[lv blue] + [pb bvalue];
	[lv blue] / 3;
	[lv blue] > 2;
	[lv blue] > [lztga save sepias];
	[bit field content] = [lv blue];
	[bit field content] | 80h;
      ? [lztga save sepias] = no -> lztga greys;
	[bit field content] | 40h;
      "lztga greys"
	=> set bit field;
	[bit field content] = [lv blue];

      "lztga vectorialize mono"
	[starting bit number] + 8;
	=> get progressive byte;
	[pb offset] +;
	[lv blue] = [pb bvalue];
	=> get progressive byte;
	[pb offset] +;
	[lv blue] + [pb bvalue];
	=> get progressive byte;
	[pb offset] +;
	[lv blue] + [pb bvalue];
	[lv blue] / 3;
	[lv blue] > 2;
	[lv blue] > [lztga save sepias];
	[lv blue] -->;
	[lv blue] - [bit field content];
	[lv blue] & ffh;
	[bit field content] = [lv blue];
	=> set bit field;
	<-- [bit field content];
	[plane pixels to do] -;
      ? [plane pixels to do] > 1 -> lztga vectorialize mono;
	[lz datasize] = 18;
	[lz datasize] + [ltp id block size];
	[lz datasize] + [plane pixels];
	-> lztga go saving;

      (color encoder)

      "lztga color"
	[plane bits] = [plane pixels];
	[plane bits] < 3;
	[rewind bits] = [plane bits];
	[rewind bits] * 3;
	[rewind bits] - 8;
	=> get progressive byte;
	[pb offset] +;
	[pb bvalue] > 3;
	[lv blue] = [pb bvalue];
	=> get progressive byte;
	[pb offset] +;
	[pb bvalue] > 2;
	[lv green] = [pb bvalue];
	=> get progressive byte;
	[pb offset] +;
	[pb bvalue] > 2;
	[lv red] = [pb bvalue];
	[bit field content] = [lv blue];
	=> set bit field;
	[starting bit number] + [plane bits];
	[bit field content] = [lv green];
	=> set bit field;
	[starting bit number] + [plane bits];
	[bit field content] = [lv red];
	=> set bit field;
	[starting bit number] + [plane bits];

      "lztga vectorialize colors"
	[starting bit number] - [rewind bits];
	=> get progressive byte;
	[pb offset] +;
	[pb bvalue] > 3;
	[pb bvalue] -->;
	[pb bvalue] - [lv blue];
	[pb bvalue] & ffh;
	[bit field content] = [pb bvalue];
	=> set bit field;
	[starting bit number] + [plane bits];
	<-- [lv blue];
	=> get progressive byte;
	[pb offset] +;
	[pb bvalue] > 2;
	[pb bvalue] -->;
	[pb bvalue] - [lv green];
	[pb bvalue] & ffh;
	[bit field content] = [pb bvalue];
	=> set bit field;
	[starting bit number] + [plane bits];
	<-- [lv green];
	=> get progressive byte;
	[pb offset] +;
	[pb bvalue] > 2;
	[pb bvalue] -->;
	[pb bvalue] - [lv red];
	[pb bvalue] & ffh;
	[bit field content] = [pb bvalue];
	=> set bit field;
	[starting bit number] + [plane bits];
	<-- [lv red];
	[plane pixels to do] -;
      ? [plane pixels to do] > 1 -> lztga vectorialize colors;
	[lz datasize] = 18;
	[lz datasize] + [ltp id block size];
	[lz datasize] + [plane pixels];
	[lz datasize] + [plane pixels];
	[lz datasize] + [plane pixels];

      (finished vectorializing pixels, begin compressing...)

      "lztga go saving"
	[lz datagram] = graphics vectorialization layer;
	[lz take bit] = zero;
	[lz wordfill] = zero;
	[lz chnksize] = 12288;
	[lz data out] = graphics decompression layer;
	[lz give bit] = zero;
	[lz size out] = pxsize mtp cpu unit;
	=> lz;

	e = 5;	(5 -- compressed data longer than source)

      ? failed -> lztga error;

	e +;	(6 -- failed to write compressed file)

      (calculate size, in bytes, of compressed streams: round [block size] to next byte)

	[block size] = [lz bits out];
	[block size] > 3;
      ? [lz bits out] - 7 -> lztga evens;
	[block size] +;

      (write compressed file)

      "lztga evens"
	[file command] = write;
	[file name] = vector selected file name;
	[file position] = zero;
	[block pointer] = graphics decompression layer;
	isocall;
      ? failed -> lztga error;

	e +;	(7 -- failed to truncate compressed file)

      (truncate compressed file to its effective size - applies to longer existing files)

	[file command] = set size;
	[file size] = [block size];
	isocall;
      ? failed -> lztga error;

	e +;	(8 -- successfully encoded)

      (eventually discard source image memory block)

      "lztga error"
      ? [lztga buffer] = null -> lztga clean;
	[ramtop] = [lztga buffer];
	isocall;

      (report errors, or successful encoding, by using register E as index of the error table)

      "lztga clean"
	[question datascript] = [e plus lztga error table];
	-> csquestion;

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				       PHOTOLIZZIE DECODER
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

      (this routine is fundamentally a "wrapper" based around "load tga picture": rather than
       expecting a regular chunk of TGA image data being passed throught [tga picture data],
       it expects a compressed stream there, in PLZ format: the rest of the call is the same
       as for "load tga picture", for which one should see the gen/TGA library; there is only
       one additional argument, [lplz draw picture]: if set, routine passes uncompressed data
       to the "load tga picture" as intended; if clear, the routine only uncompresses the data
       and copies it to [tga target layer], which may even be the same memory area pointed by
       [tga picture data], providing the are is large enough to hold the uncompressed picture.
       The routine generates no error messages, but returns with failed status on any errors.)

      (...so, the first thing is trying to LZ-uncompress what's in [tga picture data]...)

      "load photolz"
	[lz datagram] = [tga picture data];
	[lz take bit] = zero;
	[lz wordfill] = zero;
	[lz datasize] = zero;
	[lz chnksize] = 12288;
	[lz data out] = graphics decompression layer;
	[lz give bit] = zero;
	[lz size out] = pxsize mtp cpu unit;
	=> unlz;
      ? failed -> lplz failed;

      (after uncompressing, try to trace the image, passing it to "load tga picture" as it is,
       but not really drawing it by using a "service fx null" for the pixel effect... only,
       remember the real effect to be used when/if the image is really to be traced, later:
       this trial tracement serves to test if the uncompressed data is really a TGA picture)

	[tga picture data] = graphics decompression layer;
	[tga effect] -->;
	[tga effect] = service fx null;
	=> load tga picture;
	<-- [tga effect];
      ? failed -> lplz failed;

      (resulting TGA image, after being parsed by the trial call to "load tga picture", must
       be within decoder buffer size limits, and it must be truecolor: no indexed colormaps;
       additionally, the image must present at least 2 pixels as its area, due to the need of
       a base color for this routine's cheap devectorialization process...)

      ? [ltp pixels] > max picture width -> lplz failed;
      ? [ltp scanlines] > max picture height -> lplz failed;
      ? [ltp colormap size] != zero -> lplz failed;
	[plane pixels] = [ltp pixels];
	[plane pixels] * [ltp scanlines];
      ? [plane pixels] < 2 -> lplz failed;

      (prepare in/out streams pointers and copy the picture's header as it is:
       output stream is always "graphics vectorialization layer"...)

	[plane rewind] = [plane pixels];
	[plane rewind] * 3;
	[plane rewind] -;
	[pb offset] = zero;

	a = [ltp id block size];
	a + 18;
      "lplz copy header"
	a -->;
	[pb stream] = graphics decompression layer;
	=> get progressive byte;
	[pb stream] = graphics vectorialization layer;
	=> set progressive byte;
	[pb offset] +;
	<-- a;
	a ^ lplz copy header;

      (read first byte of image data: in the first byte's most significant two bits is stored
       the rendering method, as XYZZZZZZ, where:
       X - color if bit is clear, monochrome if set;
       Y - when monochrome, use sepia rendering if set, else this bit is ignored;
       Z - first channel of first pixel: channels are 3 for color, 1 for monochrome)

	[pb offset in target] = [pb offset];
	[plane pixels to do] = [plane pixels];
	[pb stream] = graphics decompression layer;
	=> get progressive byte;

      (branch to appropriate decoding loop)

      ? [pb bvalue] - 80h -> lplz color;

      (monochrome/sepia decoder)

	[lztga save sepias] = [pb bvalue];
	[lztga save sepias] & 40h;
	[lztga save sepias] > 6;
	[pb bvalue] & 3fh;
	[lv blue] = [pb bvalue];
	[pb offset] -->;
	[pb stream] = graphics vectorialization layer;
	[pb bvalue] < 2;
	[pb bvalue] < [lztga save sepias];
	[pb offset] = [pb offset in target];
      ? [lztga save sepias] = no -> lplz base grey;
	[pb bvalue] * 9;
	[pb bvalue] > 3;
	=> generate real rnd;
	[rnd] ** 16f;
	[rnd] =, [rnd];
	[pb offset] = [pb offset in target];
	[pb bvalue] -->;
	[pb bvalue] * 6;
	[pb bvalue] > 3;
	[pb bvalue] + [rnd];
      ? [pb bvalue] < 255 -> lplz proceed with sepia base blue channel;
	[pb bvalue] = 255;
      "lplz proceed with sepia base blue channel"
	=> set progressive byte;
	<-- [pb bvalue];
	[pb offset] +;
	[pb bvalue] -->;
	[pb bvalue] * 7;
	[pb bvalue] > 3;
	[pb bvalue] + [rnd];
      ? [pb bvalue] < 255 -> lplz proceed with sepia base green channel;
	[pb bvalue] = 255;
      "lplz proceed with sepia base green channel"
	=> set progressive byte;
	<-- [pb bvalue];
	[pb offset] +;
	[pb bvalue] + [rnd];
      ? [pb bvalue] < 255 -> lplz proceed with sepia base red channel;
	[pb bvalue] = 255;
      "lplz proceed with sepia base red channel"
	=> set progressive byte;
	-> lplz base sepia;
      "lplz base grey"
	[pb bvalue] + [lztga loss compensation];
	=> set progressive byte;
	[pb offset] +;
	=> set progressive byte;
	[pb offset] +;
	=> set progressive byte;
      "lplz base sepia"
	[pb offset in target] + 3;
	<-- [pb offset];

      "lplz devectorialize mono"
	[pb offset] +;
	[pb stream] = graphics decompression layer;
	=> get progressive byte;
	[pb bvalue] < 24;
	[pb bvalue] >> 24;
	[lv blue] + [pb bvalue];
	[pb bvalue] = [lv blue];
	[pb offset] -->;
	[pb stream] = graphics vectorialization layer;
	[pb bvalue] < 2;
	[pb bvalue] < [lztga save sepias];
	[pb offset] = [pb offset in target];
      ? [lztga save sepias] = no -> lplz pixel grey;
	[pb bvalue] * 9;
	[pb bvalue] > 3;
	=> generate real rnd;
	[rnd] ** 16f;
	[rnd] =, [rnd];
	[pb offset] = [pb offset in target];
	[pb bvalue] -->;
	[pb bvalue] * 6;
	[pb bvalue] > 3;
	[pb bvalue] + [rnd];
      ? [pb bvalue] < 255 -> lplz proceed with sepia pixel blue channel;
	[pb bvalue] = 255;
      "lplz proceed with sepia pixel blue channel"
	=> set progressive byte;
	<-- [pb bvalue];
	[pb offset] +;
	[pb bvalue] -->;
	[pb bvalue] * 7;
	[pb bvalue] > 3;
	[pb bvalue] + [rnd];
      ? [pb bvalue] < 255 -> lplz proceed with sepia pixel green channel;
	[pb bvalue] = 255;
      "lplz proceed with sepia pixel green channel"
	=> set progressive byte;
	<-- [pb bvalue];
	[pb offset] +;
	[pb bvalue] + [rnd];
      ? [pb bvalue] < 255 -> lplz proceed with sepia pixel red channel;
	[pb bvalue] = 255;
      "lplz proceed with sepia pixel red channel"
	=> set progressive byte;
	-> lplz pixel sepia;
      "lplz pixel grey"
	[pb bvalue] + [lztga loss compensation];
	=> set progressive byte;
	[pb offset] +;
	=> set progressive byte;
	[pb offset] +;
	=> set progressive byte;
      "lplz pixel sepia"
	[pb offset in target] + 3;
	<-- [pb offset];
	[plane pixels to do] -;
      ? [plane pixels to do] > 1 -> lplz devectorialize mono;
	-> lplz go loading;

      (color decoder)

      "lplz color"
	[pb offset] + [plane pixels];
	[lv blue] = [pb bvalue];
	=> get progressive byte;
	[pb offset] + [plane pixels];
	[lv green] = [pb bvalue];
	=> get progressive byte;
	[pb offset] + [plane pixels];
	[lv red] = [pb bvalue];
	[pb offset] -->;
	[pb stream] = graphics vectorialization layer;
	[pb offset] = [pb offset in target];
	[pb bvalue] = [lv blue];
	[pb bvalue] < 3;
	[pb bvalue] + [lztga blue compensation];
	=> set progressive byte;
	[pb offset in target] +;
	[pb offset] = [pb offset in target];
	[pb bvalue] = [lv green];
	[pb bvalue] < 2;
	[pb bvalue] + [lztga loss compensation];
	=> set progressive byte;
	[pb offset in target] +;
	[pb offset] = [pb offset in target];
	[pb bvalue] = [lv red];
	[pb bvalue] < 2;
	[pb bvalue] + [lztga loss compensation];
	=> set progressive byte;
	[pb offset in target] +;
	[pb stream] = graphics decompression layer;
	<-- [pb offset];

      "lplz devectorialize colors"
	[pb offset] - [plane rewind];
	=> get progressive byte;
	[pb bvalue] < 24;
	[pb bvalue] >> 24;
	[pb offset] -->;
	[lv blue] + [pb bvalue];
	[pb stream] = graphics vectorialization layer;
	[pb offset] = [pb offset in target];
	[pb bvalue] = [lv blue];
	[pb bvalue] < 3;
	[pb bvalue] + [lztga blue compensation];
	=> set progressive byte;
	[pb stream] = graphics decompression layer;
	<-- [pb offset];
	[pb offset] + [plane pixels];
	[pb offset in target] +;
	=> get progressive byte;
	[pb bvalue] < 24;
	[pb bvalue] >> 24;
	[pb offset] -->;
	[lv green] + [pb bvalue];
	[pb stream] = graphics vectorialization layer;
	[pb offset] = [pb offset in target];
	[pb bvalue] = [lv green];
	[pb bvalue] < 2;
	[pb bvalue] + [lztga loss compensation];
	=> set progressive byte;
	[pb stream] = graphics decompression layer;
	<-- [pb offset];
	[pb offset] + [plane pixels];
	[pb offset in target] +;
	=> get progressive byte;
	[pb bvalue] < 24;
	[pb bvalue] >> 24;
	[pb offset] -->;
	[lv red] + [pb bvalue];
	[pb stream] = graphics vectorialization layer;
	[pb offset] = [pb offset in target];
	[pb bvalue] = [lv red];
	[pb bvalue] < 2;
	[pb bvalue] + [lztga loss compensation];
	=> set progressive byte;
	[pb stream] = graphics decompression layer;
	<-- [pb offset];
	[pb offset] + [plane pixels];
	[pb offset in target] +;
	[plane pixels to do] -;
      ? [plane pixels to do] > 1 -> lplz devectorialize colors;

      (when done decoding: if requested to trace the picture, redirect to "load tga picture"
       after setting [tga picture data] to the uncompressed stream; if you aren't requested
       to trace the picture now, because the call was only for decoding it, copy decoded data
       to location given by [tga target layer], and return...)

      "lplz go loading"
	[tga picture data] = graphics vectorialization layer;
      ? [lplz draw picture] = yes -> load tga picture;
	a = [tga picture data];
	b = [tga target layer];
	c = [pb offset in target];
	c > 2;
      ? [pb offset in target] - 3 -> lplz copy only;
	c +;
      "lplz copy only"
	[b] = [a];
	a +;
	b +;
	c ^ lplz copy only;
	end;

      "lplz failed"
	fail;

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				      STORYBOOKS PACKAGER
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

      (popup menu's file selector hook: setup iGUI's file selector to list .txt files)

      "package story"
	[file selector filter] = stories extension;
	[on file select] = service package story;
	leave;

      (once storybook is selected, this routine is entered with "vector selected file name" set
       to the path and name of the target storybook file... processing begins with a notice...)

      "service package story"
	[question datascript] = packaging;
	=> csnotice;

      (zero [pkg block] to signal there's no memory block to discard so far, should it return)

	[pkg block] = null;

      (set error phase counter, as register E, to zero)

	e # e;	(0 -- can't access core executable)

      ("startup directory" is preserved by the iGUI as the path to the directory from where
       the program was launched, where "The Narrator.exe" is expected to be found: that path
       is copied to "this narrator executable", a slash is appended, and "The Narrator.exe"
       is finally appended to the whole...)

	[source string] = startup directory;
	[target string] = this narrator executable;
	=> strcpy;
	[source string] = path slash;
	=> strcat;
	[source string] = narrator executable;
	=> strcat;

      (test "/{startup directory}/The Narrator.exe" to see if it's accessible)

	[file command] = test;
	[file name] = this narrator executable;
	isocall;
      ? failed -> pkg error;

	e +;	(1 -- out of memory reading core executable)

      (allocate a block of memory of size [pkg block size] to hold "The Narrator.exe")

	[narrator executable size] = [file size];
	[pkg block size] = [file size];
	[pkg block size] > 2;
	[pkg block size] +;
	[pkg block] = [ramtop];
	[ramtop] + [pkg block size];
	isocall;
      ? failed -> pkg error;

	e +;	(2 -- can't read core executable)

      (read "The Narrator.exe" into the newly allocated block)

	[file command] = read;
	[file name] = this narrator executable;
	[file position] = zero;
	[block pointer] = [pkg block];
	[block size] = [file size];
	isocall;
      ? failed -> pkg error;

	e +;	(3 -- can't find defstory marker)

      (here comes the part that finds where "The Narrator.exe" significant parts end: search
       for "atSTORY", the small-endian, ASCII encoding of "@STO", which is expected to mark
       the position of "build/defstory.txt", where the packaged storybook executable will look
       for its storybook file; there are of course several occurrences of the string "@STO" in
       the program's code, including the ones resulting from compiling the following code, and
       that's why the loop that scans "The Narrator.exe" is told to continue scanning until a
       precise number of "fake occurrences" are found, as indicated by [occurrences to do]:
       the count is actually 7, meaning 6 occurrences are "fakes", and the 7th one is real,
       is what the loop was looking for; once the 7th occurrence is found, its offset in units
       since the beginning of "The Narrator.exe" is given by A - [pkg block], then multiplied
       by 4 to transform the offset into an amount of bytes, and added register D, which is the
       offset of the byte where @STO begins within the unit indicated by A: at that point D may
       hold values between 0 to 3. So, the formula {A - [pkg block]} * 4 + D gives the exact
       position, in bytes since the beginning of "The Narrator.exe", of the @ sign in "@STO":
       this result is finally stored into [narrator executable size], and will represent the
       offset at which packaged storybooks will be appended to the program's executable core,
       to exactly replace "build/defstory.txt" and be read in place of that...)

	[occurrences to do] = 7;
	[units to do] = [pkg block size];

	a = [pkg block];

      "pkg find default story"
	b = [a];
	c = [a plus 1];
	d # d;
      ? b = atSTORY -> pkg found default story;
	b > 8;
	d = c;
	d < 24;
	b | d;
	d = 1;
      ? b = atSTORY -> pkg found default story;
	b > 8;
	d = c;
	d < 16;
	d & ff000000h;
	b | d;
	d = 2;
      ? b = atSTORY -> pkg found default story;
	b > 8;
	d = c;
	d < 8;
	d & ff000000h;
	b | d;
	d = 3;
      ? b = atSTORY -> pkg found default story;

      "pkg not really"
	a +;
	[units to do] ^ pkg find default story;
	-> pkg error;

      "pkg found default story"
	[occurrences to do] ^ pkg not really;

	a - [pkg block];
	a < 2;
	a + d;
	[narrator executable size] = a;

	e +;	(4 -- invalid storybook file name)

      (make out base file name, ie. selected file name, minus ".txt")

	[source string] = vector selected file name;
	[target string] = package base file name;
	=> strcpy;
	[source string] = package base file name;
	[target string] = stories extension;
	=> strstr;
      ? failed -> pkg error;
	a = [target string];
      ? [a plus 4] != 0 -> pkg error;
	[a] = null;

      (make out the bare filename by also removing the path to it: the path is supposed to
       begin with a forward slash, as it should always be, so the following code copies base
       file name to "storybook ascii contents", then searchs for the first slash and wouln't
       tolerate not finding it...)

	[source string] = package base file name;
	[target string] = storybook ascii contents;
	=> strcpy;
	[source string] = storybook ascii contents;
	[target string] = path slash;
	=> strstr;
      ? failed -> pkg error;

      (...and the following loop keeps matching forward slashes until the very last one is
       found, marking the end of the path: because of how the loop is structured, after it's
       matched the last slash, [source string] is left to point to the first character after
       that slash, being the first character of the effective file name, which is then copied
       back to match the first unit of "storybook ascii contents"...)

      "pkg remove path"
	[source string] = [target string];
	[source string] +;
	[target string] = path slash;
	=> strstr;
      ? ok -> pkg remove path;
	[target string] = storybook ascii contents;
	=> strcpy;

      (ok, now find the length of the bare file name which, in conclusion, for my storybook
       called "/d/lp/the narrator/samples/alex's world.txt", would be "alex's world", to
       preserve [string length] for future use: all this thing of insulating the file name
       was done to have the storybook's bare file name saved within the compressed package,
       because "alex's world", in that case, would be used to create "alex's world.inf" as
       the situation file, once the packaged storybook is self-uncompressed and played...)

	[source string] = storybook ascii contents;
	=> strlen;
	[string length] +;

	e +;	(5 -- can't access storybook file)

      (see if selected storybook file is accessible, and get its size in bytes as [file size])

	[file command] = test;
	[file name] = vector selected file name;
	isocall;
      ? failed -> pkg error;

	e +;	(6 -- can't read storybook file)

      (load the storybook file within "storybook ascii contents", but *appending* it to the
       existing "bare file name" that I copied there with the previous code... the file name
       will remain terminated by its final null unit, so it will be separated from the text
       found within the storybook file...)

	[file command] = read;
	[file name] = vector selected file name;
	[file position] = zero;
	[block pointer] = storybook ascii contents;
	[block pointer] + [string length];
	[block size] = [file size];
	isocall;
      ? failed -> pkg error;

	e +;	(7 -- out of memory compressing storybook)

      (add the bare file name string's length, preserved from above, to the file size, but
       consider the string was a fourbyte string, while [file size] was in bytes, and a
       conversion to calculate string length in bytes is necessary...)

	[string length] * bytes per unit;
	[file size] + [string length];

      (find a pointer to the unit holding the @STO marker, from [narrator executable size],
       for the moment disregarding the precise byte within that unit by truncating it to the
       previous unit boundary, then use [file size], rounded instead to the NEXT unit boundary,
       to determine the amount of extra memory to allocate for holding the packaged storybook
       data block which is to be formed by "The Narrator.exe" plus the actual contents of
       buffer "storybook ascii contents", and allocate extra memory...)

	[pkg storybook] = [narrator executable size];
	[pkg storybook] > 2;
	[pkg storybook] + [pkg block];
	[pkg storybook size] = [file size];
	[pkg storybook block size] = [file size];
	[pkg storybook block size] > 2;
	[pkg storybook block size] +;
	[ramtop] + [pkg storybook block size];
	isocall;
      ? failed -> pkg error;

      (LZ-compress "storybook ascii contents", giving resulting compressed stream to the
       area indicated by the pointer found by above code, being [pkg storybook]: setup
       [lz give bit], here, to consider the byte offset that was not considered before...
       after compression is completed, round output size to next byte and store the size
       of compressed stream representing "storybook ascii contents" as [pkg storybook size])

	[lz datagram] = storybook ascii contents;
	[lz take bit] = zero;
	[lz wordfill] = zero;
	[lz datasize] = [file size];
	[lz chnksize] = 12288;
	[lz data out] = [pkg storybook];
	[lz give bit] = [narrator executable size];
	[lz give bit] & bytes per unit minus 1;
	[lz give bit] < 3;
	[lz size out] = [pkg storybook size];
	[lz size out] < 3;
	=> lz;
	e = 8;	(8 -- failed to compress storybook)
      ? failed -> pkg error;

	e +;	(9 -- can't write package file)

	[pkg storybook size] = [lz bits out];
	[pkg storybook size] > 3;
      ? [lz bits out] - 7 -> pkg storybook evens;
	[pkg storybook size] +;

      (generate package file name, as base file name + ".exe")

      "pkg storybook evens"
	[source string] = package base file name;
	[target string] = package file name;
	=> strcpy;
	[source string] = exe extension;
	=> strcat;

      (save base packet, ie. narrator executable + compressed story block)

	[file command] = write;
	[file name] = package file name;
	[block pointer] = [pkg block];
	[block size] = [narrator executable size];
	[block size] + [pkg storybook size];
	isocall;
      ? failed -> pkg error;

	e +;	(10 -- can't truncate package file)

      (truncate base packet to its effective size - applies to longer existing files)

	[file command] = set size;
	[file name] = package file name;
	[file size] = [block size];
	isocall;
      ? failed -> pkg error;

      (void components table: the first component file offset, which is supposed to be always
       zero anyway, holds the number of files in components table instead, and it's the first
       record of the table, so just zero the first unit of the table, and make the table size
       for compression be determined by that single unit, being 4 bytes: when a storybook is
       read from a self-extracting package, such a table is ALWAYS expected to be there, even
       if it can be void; a void table means no additional files, other than the storybook,
       are necessary for the package to work...)

	[package components table] = zero;
	[lz datasize] = bytes per unit;

      (to collect pictures, generate package pictures' folder name = base file name + "_files")

	[source string] = package base file name;
	[target string] = package pictures folder name;
	=> strcpy;
	[source string] = pictures folder;
	=> strcat;

      (switch to pictures folder for retrieving its directory listing:
       if there's no such folder, leave a void components table...)

	[file command] = set dir;
	[file name] = package pictures folder name;
	isocall;
      ? failed -> pkg no components;

      (retrieve listing, and filter out anything that's got no ".plz" extension:
       phase 1: while doing that, append records to package's components table...)

	[pkg file command] = get first file;

	[components table records] = zero;
	[components table record pointer] = package components table;
	[components table file offset] = zero;

      "pkg r1 next picture"
	[file command] = [pkg file command];
	[pkg file command] = get next file;
	[file name] = component file name;
	isocall;
      ? failed -> pkg r1 no further pictures;
	[source string] = component file name;
	[target string] = plz extension;
	=> strstr;
      ? failed -> pkg r1 next picture;
	a = [target string];
      ? [a plus 4] != 0 -> pkg r1 next picture;
	[source string] = package base file name;
	[target string] = package pictures folder name;
	=> strcpy;
	[source string] = pictures folder;
	=> strcat;
	[source string] = path slash;
	=> strcat;
	[source string] = component file name;
	=> strcat;
	[file command] = test;
	[file name] = package pictures folder name;
	isocall;
	e = 11; (11 -- can't access component)
      ? failed -> pkg error;
	[a] = null; (truncating .plz extension out of <component file name>)
	[components table file symbol] = zero;
	a = component file name;
      "pkg generate filename hash"
	b = [a];
	a +;
      ? b = null -> pkg hash completed;
      ? b < 65 -> pkg add characters; (A)
      ? b > 90 -> pkg add characters; (Z)
	b + 32;
      "pkg add characters"
	b * 123;
	b & ffh;
	[components table file symbol] # b;
	[components table file symbol] @> 8;
	-> pkg generate filename hash;
      "pkg hash completed"
	a = [components table record pointer];
	[a plus 0] = [components table file offset];
	[a plus 1] = [components table file symbol];
	[components table file offset] + [file size];
	[components table record pointer] + 2;
	[components table records] +;
	e = 12; (12 -- too many component files)
      ? [components table records] = max package components -> pkg error;
	-> pkg r1 next picture;

      (use first recorded file's offset field, which is supposed to hold 0 in any cases,
       to instead hold the count of records in the components' table; of course, if no
       files were found as components in pictures' folder, the table remains void...)

      "pkg r1 no further pictures"
      ? [components table records] = zero -> pkg no components;

	[package components table] = [components table records];
	[lz datasize] = [components table record pointer];
	[lz datasize] - package components table;
	[lz datasize] * bytes per unit;

      (compress components table into memory)

      "pkg no components"
	[lz datagram] = package components table;
	[lz take bit] = zero;
	[lz wordfill] = zero;
	[lz chnksize] = 1536;
	[lz data out] = compressed components table;
	[lz give bit] = zero;
	[lz size out] = 2 mtp max package components mtp cpu unit;
	=> lz;
	e = 13; (13 -- failed to compress components table)
      ? failed -> pkg error;

	e +;	(14 -- can't write components table)

      (evenize compressed components table size, for saving)

	[block size] = [lz bits out];
	[block size] > 3;
      ? [lz bits out] - 7 -> pkg cctable evens;
	[block size] +;

      (append compressed components table to package file)

      "pkg cctable evens"
	[file command] = write;
	[file name] = package file name;
	[file position] = [narrator executable size];
	[file position] + [pkg storybook size];
	[block pointer] = compressed components table;
	isocall;
      ? failed -> pkg error;

      (retrieve listing, and filter out anything that's got no ".plz" extension:
       phase 2: while doing that, append each single file to package file...)

	[pkg file command] = get first file;

      "pkg r2 next picture"
	[file command] = [pkg file command];
	[pkg file command] = get next file;
	[file name] = component file name;
	isocall;
      ? failed -> pkg ready;
	[source string] = component file name;
	[target string] = plz extension;
	=> strstr;
      ? failed -> pkg r2 next picture;
	a = [target string];
      ? [a plus 4] != 0 -> pkg r2 next picture;
	[source string] = package base file name;
	[target string] = package pictures folder name;
	=> strcpy;
	[source string] = pictures folder;
	=> strcat;
	[source string] = path slash;
	=> strcat;
	[source string] = component file name;
	=> strcat;
	[source file] = package pictures folder name;
	[target file] = package file name;
	=> fcat;
	e = 15; (15 -- can't link component)
      ? failed -> pkg error;
	-> pkg r2 next picture;

      (report errors by using register E as index of the error table)

      "pkg error"
	[question datascript] = [e plus pkg error table];
	=> csquestion;
	-> pkg cleanup;

      (report successful packaging)

      "pkg ready"
	[question datascript] = packaged successfully;
	=> csquestion;

      "pkg cleanup"
	[file command] = set dir;
	[file name] = startup directory;
	isocall;

      ? [pkg block] = null -> pkg clean;
	[ramtop] = [pkg block];
	isocall;

      "pkg clean"
	leave;

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				 "PLAY STORY" OPTION HANDLER
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

      (popup menu's file selector hook: setup iGUI's file selector to list .txt files)

      "play story"
	[file selector filter] = stories extension;
	[on file select] = service play new story;
	leave;

      (once storybook is selected, this routine is entered with "vector selected file name" set
       to the path and name of the storybook file to load and run: begin by saving situation)

      "service play new story"
	=> save situation;

      (if called as a menu option, automatically load an eventual situation file and branch to
       "service main loop" after loading the storybook, to parse it and refresh the display...)

	[pns return] = false;

      (test storybook file for accessibility, and alternative entry point from program's main
       flow, which calls here upon trying to load a storybook file which name has been passed
       as a command line argument...)

      "play new story"
	[file command] = test;
	[file name] = vector selected file name;
	isocall;
      ? failed -> file not found;

      (generate situation file name)

	[source string] = vector selected file name;
	[target string] = storybook situation file;
	=> strcpy;
	[source string] = storybook situation file;
	[target string] = stories extension;
	=> strstr;
      ? failed -> file extension not lowercase;
	a = [target string];
      ? [a plus 4] != 0 -> no proper final extension;
	[a] = null;
	[source string] = situations extension;
	[target string] = storybook situation file;
	=> strcat;

      (set pointers to storybook and situation files, call storybook loader)

	[pointer to storybook file name] = vector selected file name;
	[pointer to situation file name] = storybook situation file;
	[storybook file position] = zero;
	=> load storybook;
      ? [valid storybook file] = yes -> go on with the new story;

      "no valid storybook file"
	-> revert to defstory;

      "file not found"
	-> revert to defstory;

      "file extension not lowercase"
	-> revert to defstory;

      "no proper final extension"

      (on load errors, load build/defstory.txt in replacement: note that this cannot happen in
       packaged, self-extracting storybooks, because such programs don't show the "load story"
       option, so they can't get here, which is appropriate, because at this point "defstory"
       would be in fact the packaged storybook...)

      "revert to defstory"
	[number of symbols] = zero;
	[storybook file size] = zero;
	[pointer to situation file name] = null;
	[pointer to storybook file name] = null;
	[storybook file position] = defstory;
	=> load storybook;

      (on success, if a situation file is present, it will be loaded; if there was an error,
       the pointer to the situation file name would be null and "load situation" do nothing:
       then, exit to main loop for a refresh of the display...)

      "go on with the new story"
      ? [pns return] = false -> behave as menu option;
	leave;

      "behave as menu option"
	=> load situation;
	-> service main loop;

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				  SIMPLER MENU OPTION HANDLERS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

      (copy story credits trigger, which is a pre-defined, hardcoded answer, into player
       answer buffer, and then try to parse it: of course the storybook is supposed to
       handle the trigger in its own way...)

      "show story credits"
	[source string] = credits trigger;
	[target string] = answer buffer;
	=> dsexpand;
	[source string] = answer buffer;
	=> strlen;
	[answer length] = [string length];
	-> parse players answer;

      (show program credits dialog box: after all this work and writing all these annoying
       comments, and time spent organizing the code in a decent layout, and optimizations,
       and bugfixing... I *demand* this option to remain there, always!)

      "show credits"
	[question datascript] = credits;
	-> csquestion;

      (yup, jump to my site by triggering the system's default browser if the user's curious)

      "anywhere i am"
	[file name] = site link;
	-> csrun;

      (this is an URL leading to my contact form)

      "tell alex"
	[file name] = contact link;
	-> csrun;

      (and this is the URL to the home thread of The Narrator within my site)

      "download narrator"
	[file name] = download link;
	-> csrun;

      (and this is... hmmm... what's this? it's absolutely cryptic! may be hidden malware?)

      "quit program"
	[quit now] = yes;
	leave;

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			WORK AREA MANAGER, AND ITS AUXILIARY SUBROUTINES
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

      (the following subroutine clears and retraces the "canvas layer", which is then used as
       a background over which the player's answer text, and its cursor, is traced; canvas is
       copied to backdrop layer, which is the layer upon which iGUI traces the mouse pointer:
       the canvas is actually reset to the grey frame and white background with the signature
       logo in the lower right corner - the storybook parser will then trace output text over
       these elements, on the same "canvas layer". Begin by clearing the layer with black...)

      "display cleanup"
	[destination layer] = canvas layer;
	[l2l region] = vector work area;
	[l2l region color] = null;
	=> clear l2l region;

      (trace the top of the grey frame:
       avoid redundant load of [destination layer] = canvas layer)

	[left margin relating eraser bounds] = [left margin relating vector work area];
	[top margin relating eraser bounds] = [top margin relating vector work area];
	[right margin relating eraser bounds] = [right margin relating vector work area];
	[bottom margin relating eraser bounds] = [top margin relating vector work area];
	[bottom margin relating eraser bounds] +;
	[l2l region] = eraser bounds;
	[l2l region color] = cacacah;
	=> clear l2l region;

      (trace the bottom part of the grey frame, by shifting destination layer pointer)

	a = [display height];
	a - 25 plus 3;
	a * [display width];
	[destination layer] + a;
	=> clear l2l region;

      (trace left part of the frame:
       avoid redundant load of [l2l region color] = cacacah,
       avoid redundant load of [l2l region] = eraser bounds)

	[bottom margin relating eraser bounds] = [bottom margin relating vector work area];
	[right margin relating eraser bounds] = [left margin relating vector work area];
	[right margin relating eraser bounds] +;
	[destination layer] = canvas layer;
	=> clear l2l region;

      (trace right part of the frame, by shifting destination layer pointer)

	a = [display width];
	a - 4;
	[destination layer] + a;
	=> clear l2l region;

      (trace white background inside the frame:
       use a register in place of numeric constant "3" because it takes less bytes of code,
       so leave a 1-pixel black margin around, thanks to the initial black cleanup,
       and avoid redundant load of [l2l region] = eraser bounds)

	a = 3;

	[right margin relating eraser bounds] = [right margin relating vector work area];
	[left margin relating eraser bounds] + a;
	[top margin relating eraser bounds] + a;
	[right margin relating eraser bounds] - a;
	[bottom margin relating eraser bounds] - a;
	[destination layer] = canvas layer;
	[l2l region color] = ffffffh;
	=> clear l2l region;

      (trace signature logo in bottom left corner)

	[tga picture data] = version shape;
	[tga target layer] = canvas layer;
	[tga display alignment] = [display width];
	[tga display height] = [display height];
	[tga picture left] = [right margin relating vector work area];
	[tga picture left] - 140 plus 3 minus 1;
	[tga picture top] = [bottom margin relating vector work area];
	[tga picture top] - 100 plus 3 minus 1;
	[tga effect] = service fx raw;
	[lplz draw picture] = yes;
	=> load photolz;

      (record display dimensions to determine if future clean-ups will be needed: display size
       can be uncertain, although it's ideally fixed, cause L.in.oleum programs may be witheld
       from overlapping the OS interface's forbidden areas of the physical screen, such as the
       task bar and other similar accessories in Windows; in such cases, which happen when the
       desktop resolution is EXACTLY 640x480 and this program can't take the whole screen, but
       only a certain rectangular region of it, switching to full-screen mode will eventually
       change at least one of the dimensions: at that point, the program is supposed to redraw
       the canvas layer, to refit its contents, among which the grey frame and the storybook's
       visual outputs, rather than simply copying it to the backdrop layer for a cheap retrace)

	[known display width] = [display width];
	[known display height] = [display height];
	[tgat display alignment] = [display width];
	[tgat display height] = [display height];
	leave;

      (this is what the iGUI calls the "work area manager", and a Windows GUI application would
       call a "WndPaint" procedure: it gets called when there's the need to redraw the window's
       contents; because of the fact that "canvas layer" contains all non-floating content of
       the window, it only takes copying canvas to backdrop and then retrace the floating parts
       over the backdrop layer: effective display refresh by use of [display command] = retrace
       is performed by the iGUI after calling this subroutine. Typically, this subroutine runs,
       for example, after a pull-down menu goes away and underlying elements must be retraced:
       upon switching to/from full-screen mode to windowed mode, display dimensions may result
       slightly changed to account for task bars etc... and this routine redirects to the main
       game loop which, in turn, triggers a "display cleanup" and reparses the storybook to fit
       its visual output to the new display dimensions...)

      "service display refresh"
      ? [known display width] != [display width] -> service main loop;
      ? [known display height] != [display height] -> service main loop;
	[source layer] = canvas layer;
	[destination layer] = backdrop layer;
	[l2l region] = vector work area;
	=> copy l2l region;

      (this is used in the code below to signal that what's to retrace of the prompt line is
       not that part of the text which is enclosed by region "cursor line", but the whole line:
       the "cursor line" region, and especially its left margin used to clip left-side parts of
       the text, will be defined with a non-zero left margin in a later call to "retrace prompt
       line", made when only the surroundings of the cursor are to be retraced, to make the
       program faster on retracing changes while keyboard is used to edit the line's contents;
       the principle used to clip the left part of the line is the same used to clip the left
       part of the crescent cursor so it won't overlap the canvas' grey frame when the prompt
       line is void and the cursor lays nearby the left side of that frame...)

	[left margin relating cursor line] = zero;

      (as part of the above subroutine, and an alternative entry point, the code below traces
       what "floats" above the canvas, which is the answer prompt text and its text cursor...
       the effect is "alpha dim", so text font color channels are subtracted from the white
       background: red reduction is 1, meaning red channel is halved before that subtraction,
       causing text pixels to effectively reduce green and blue two times more than they reduce
       red, and ultimately causing the prompt text to appear reddish, which is what I want...)

      "retrace prompt line"
	[tgat target layer] = backdrop layer;
	[tgat target layer] + [left margin relating cursor line];
	[tgat source string] = answer buffer;
	[tgat left margin] = [caret x];
	[tgat left margin] - [left margin relating cursor line];
	[tgat top margin] = [caret y];
	[tgat effect] = service fx alpha dim;
	[tgat red reduction] = 1;
	[tgat green reduction] = 0;
	[tgat blue reduction] = 0;
	=> tga text;
	[tgat current left margin] + [left margin relating cursor line];

      (position text cursor as the top left corner of next character to be displayed, and the
       future, eventual position of the mouse "what cursor", which is slightly right and
       bottom of the text cursor's last position, since it's supposed to "point the player's
       eyes" to the problem answer and encourage the player to try again...)

	[text cursor x] = [tgat current left margin];
	[text cursor x] - 11;
	[what cursor x] = [text cursor x];
	[what cursor x] + 18;
	[text cursor y] = [tgat current top margin];
	[text cursor y] - 4;
	[what cursor y] = [text cursor y];
	[what cursor y] + 20;

      (the "cresent" cursor will be traced as a PLZ-compressed TGA image; arguments to
       the "load photolz" wrapper are the same as those of "load tga picture", however,
       notice the trick to clip the left side of the crescent: target layer is given as
       the pointer to backdrop layer PLUS 4 units, ie plus 4 pixels. Because "load tga
       picture" will on itself avoid any tracement below coordinates 0;0 of the target
       layer - and for that matter, also out of [display width] and [display height], the
       cursor will be traced 4 pixels to the right of its intended position as given by
       coordinates in [tga picture left];[tga picture top], BUT if I adjust this error by
       subtracting 4 pixels to those coordinates, I'll get the picture in the right place
       while "load tga picture" believes the display ends 4 pixels before its "real" end,
       automatically getting it to clip the cursor so it won't overlap my thin frame...)

	[tga picture data] = text cursor shape;
	[tga target layer] = backdrop layer plus 4;
	[tga display alignment] = [display width];
	[tga display height] = [display height];
	[tga picture left] = [text cursor x];
	[tga picture left] - 6 plus 4;
	[tga picture top] = [text cursor y];
	[tga picture top] - 3;
	[tga effect] = service fx alpha dim;

      (one last precaution: "load photolz" will by default tend to compensate the loss of
       intensity given by the reduction from 8 bits per channel to 6 bits for red and green,
       and 5 bits for blue; while this is fine to get full white under normal circumstances
       where a pixel *might* be fully white, it's deletery when using effects like "alpha dim",
       because the black background around the cresent would not be purely black, and cause an
       almost invisible, but still annoying, dark frame around the cursor's image, so for this
       case I'm temporarily zeroing the compensation factors for "load photolz"...)

	[lztga loss compensation] = 0;
	[lztga blue compensation] = 0;
	=> load photolz;
	[lztga loss compensation] = 3;
	[lztga blue compensation] = 7;
	leave;

      (what's called here "main loop" has nothing to do with the iGUI's "control loop": that's
       declared later as "story control loop"; the following subroutine is the game loop that
       executes between one player move and the next...)

      "service main loop"
	=> display cleanup;

      (reset picture area for text wrap - no picture yet)

	[storybook picture top] = zero;
	[storybook picture bottom] = zero;

      (move cursor to upper left corner)

	[caret x] = text left margin;
	[caret y] = text top margin;

      (reset wordwrap "memories")

	[caret x before last word] = text left margin;
	[pointer to last word] = zero;

      (call storybook parser to write outputs on canvas layer: main loop is entered here to
       skip display cleanup operations performed above, when there's the need to re-parse
       the storybook in consequence of a click on a pushable link, which is not supposed to
       clear the screen, because it's seen and executed as a subroutine of the storybook...)

      "main loop after push to clause"
	=> parse storybook;

      (copy window controls from backdrop to canvas: sometimes the program needs to copy back
       from the topmost parts of the canvas to the backdrop, and specifically, I've materially
       realized it happens when the answer prompt cursor is very near to the top edge of the
       storybook's "viewport", ie. the framed place where text and pictures go... oh, iGUI's
       window controls are always within the topmost 25 pixels of the display, so calculating
       the bounds of the region to copy is a piece of cake. This copy is done here to reflect
       the latest title in the window's title bar.)

	a # a; (a = 0)

	[left margin relating eraser bounds] = a;
	[top margin relating eraser bounds] = a;
	[right margin relating eraser bounds] = [display width];
	[right margin relating eraser bounds] -;
	[bottom margin relating eraser bounds] = 24;

	[l2l region] = eraser bounds;
	[source layer] = backdrop layer;
	[destination layer] = canvas layer;
	=> copy l2l region;

      (after the parser wrote outputs, caret position will have changed to match the last
       line of text written by the storybook: leave some space to place the answer prompt
       cursor below... admittedly, the metrics here are *slightly* arbitrary...)

	[caret y] + text line spacing minus 1;

      (if, at this point, the prompt line would overlap a picture, skip the picture)

      ? [storybook picture bottom] < [caret y] -> caret not overlapping picture;
	[caret y] = [storybook picture bottom];
	[caret y] + text top margin minus 28;

      (build and fill a region for the rule separating the prompt from the text:
       use registers to create compact code, avoid redundant loads, leave black margin)

      "caret not overlapping picture"
	a = 3;
	b = [caret y];
	[left margin relating cursor line] = [left margin relating vector work area];
	[left margin relating cursor line] + a;
	[top margin relating cursor line] = b;
	[right margin relating cursor line] = [right margin relating vector work area];
	[right margin relating cursor line] - a;
	[bottom margin relating cursor line] = b;
	[bottom margin relating cursor line] + a;
	[l2l region] = cursor line;
	[l2l region color] = 000000h;
	[destination layer] = canvas layer;
	=> clear l2l region;
	[top margin relating cursor line] +;
	[bottom margin relating cursor line] -;
	[l2l region color] = cacacah;
	=> clear l2l region;

      (place caret below the rule to write answers there)

	[caret y] + text top margin minus 25;
	[caret x] = text left margin;

      (place cursor image where appropriate)

	[text cursor x] = [caret x];
	[text cursor x] - 11;
	[text cursor y] = [caret y];
	[text cursor y] - 4;

      (assume the player isn't clicking over a pushable link with the mouse, for now: the
       so-called "story control loop" would realize if he/she is at its next iteration anyway)

	[pushing area] = no;

      (tell "update answer on screen" to perform a complete retrace of the display: something
       might have changed in the displayed storybook output, between one move and another...)

	[update only vicinity of cursor] = no;

      (if main loop is called after parsing an answer that didn't match any conditions in the
       storybook, ie. if [answer rejected], skip to copy the answer backup to the actual
       buffer, so the player may decide to make corrections to it...)

      ? [answer rejected] = yes -> current answer has not been accepted;

      (otherwise, if the answer matched a possible move in the game, disable the "what cursor",
       which is a special mouse pointer indicating that the game didn't know what to do with
       that answer, and clear the answer buffer to prepare it for a new move...)

	[what cursor active] = no;
	[pointer to arrow shape] = norm cursor shape;
	[answer length] = zero;
	[answer buffer] = null;
	-> update answer on screen;

      (copy back answer backup buffer)

      "current answer has not been accepted"
	a = answer buffer;
	b = answer backup buffer;
	c = [answer length];
	c +;

      "restore answer"
	[a] = [b];
	a +;
	b +;
	c ^ restore answer;

	-> update answer on screen;

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			GUI CONTROL LOOP, AND ITS AUXILIARY SUBROUTINES
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

      (this is called continuously by the iGUI: it's a real-time control loop hooked via the
       [control loop] pointer of the iGUI, running at every "frame" of the application's
       display "animation", if so I could say... note that such a continuous loop doesn't
       hog all of the CPU time because the iGUI will leave 10 milliseconds, the default value
       of iGUI's variable [control loop idle slice] between one iteration and the next, for
       other applications to perform their tasks: because control loops like this one usually
       host no further loops within them, an iteration means thousand times less than 10 msec,
       thus typically leaving 99% of the CPU time free for other programs, as it should be for
       any decent multitasking application, while its process is doing nothing in particular,
       ie. it's waiting for user input, and only rarely doing quick stuff to animate its mouse
       pointer and other interface elements, which is what happens in the following code...)

      "service story control loop"
      ? [client owns mouse pointer] = no -> control keyboard;

      (if the mouse pointer lays in an area that you can consider to be under your control,
       ie. if it's not hovering an iGUI element such as window control buttons, captions,
       pull-down menus, file selectors... which is checked by the above comparison, then see
       if the mouse pointer is within the area of the display where there could be "pushable
       areas" as defined by the storybook: the bounds of that area are checked below...)

      ? [pointer x coordinate] > max hpixel -> out of pushable areas;
      ? [pointer x coordinate] < text left margin -> out of pushable areas;
      ? [pointer y coordinate] > max vpixel -> out of pushable areas;
      ? [pointer y coordinate] < text top margin -> out of pushable areas;

      (if the mouse pointer isn't outside of that area, see if it's effectively hovering some
       pushable link: the storybook parser fills a "reference layer" made of one scanline every
       line of text, ie. reference layer has one pixel every <text line spacing> pixels of the
       visible display; the following formula computes the location, in that layer, of the
       pixel below the mouse pointer: as filled by "parse storybook", that pixel will contain
       the value <nothing to push> if it doesn't correspond to pushable links, <spliced area>
       if it's part of a clipped-out area of text that cannot hold pushable links - such as the
       clips around wordwrapping PUSH...TO text spans - or, if it contains none of the above, a
       direct pointer to the first instruction of the WELL... subroutine that the storybook has
       associated to the text span)

	a = [pointer y coordinate];
	a - text top margin;
	a / text line spacing;
	a * constant width;
	a + [pointer x coordinate];
      ? [a relating reference layer] = nothing to push -> out of pushable areas;
      ? [a relating reference layer] = spliced area -> out of pushable areas;

      (if the computer gets to execute what follows it means the pointer is hovering a pushable
       link, the destination of which would be held by [a relating reference layer], register A
       being the offset, based at zero, of the pixel below the pointer's "hot spot", calculated
       with the above formula: this part of the control loop disregards for now the destination
       address of the subroutine to parse within "storybook symbolic contents", but will change
       the mouse pointer's appearence to indicate the player that that area can be clicked, and
       jump to "hovering pushable area": once there, it will effectively check if the player is
       clicking at this moment; yet, it'll wait for the RELEASE of left mouse button to execute
       the subroutine...)

	[pointer to arrow shape] = push cursor shape;
	-> hovering pushable area;

      (if there's no pushable link below the mouse pointer's hotspot, turn off the flag
       [pushing area], which remembers if the player LOWERED the left mouse button over
       a pushable area; then, proceed in any cases to "not hovering pushable area", but
       unless the "what cursor" is active, also turn the mouse pointer to its "normal"
       appearence, just in case it's now hovering OUT of a pushable area...)

      "out of pushable areas"
	[pushing area] = no;
      ? [what cursor active] = yes -> not hovering pushable area;
	[pointer to arrow shape] = norm cursor shape;
	-> not hovering pushable area;

      (this part is reached, from above, when the pointer is hovering a pushable area of the
       displayed output: here, it checks if the left mouse button is actually down, and if it
       is, turns on the flag [pushing area]; if the button isn't being held down, it will go
       to check that same flag to see if the button WAS down, and now it no longer is: in that
       case, the player finished clicking on the area, and The Narrator will have to launch the
       associated subroutine, which address is STILL given by [a relating reference layer], for
       nothing touched the value of register A since the time it was calculated by above code)

      "hovering pushable area"
      ? [pointer status] - left button down -> not pushing area;
	[pushing area] = yes;
	-> not released after pushing;

      "not pushing area"
      ? [pushing area] = no -> not released after pushing;

      (executing subroutine associated with PUSH...TO text span: save pixel offset in reference
       layer, being register A, then clean up the display, making it a void "canvas"...)

	a -->;
	=> display cleanup;
	<-- a;

      (reset picture area for text wrap - no picture yet)

	[storybook picture top] = zero;
	[storybook picture bottom] = zero;

      (move cursor to upper left corner)

	[caret x] = text left margin;
	[caret y] = text top margin;

      (reset wordwrap "memories")

	[caret x before last word] = text left margin;
	[pointer to last word] = zero;

      (set first location of storybook's "stack" to hold a forceful return address for the
       subroutine associated with that PUSH...TO link: the return address always corresponds
       to [storybook file size], which is one unit past the end of the storybook's executable
       contents; once the subroutine returns, it will cause the storybook's parser to also
       return control to this piece of code, after the call to "push to clause entry", which
       in turns calls "parse storybook". So, the first unit of "return addresses" is set to
       the size of the storybook to work as the only saved return address, because the stack
       pointer, register B, will be set to 1, and the first unit of [conditional levels] is
       set to zero to mean that on return, the parser will be outside any conditional blocks,
       being at the end of the storybook, although that wouldn't be needed, but just for a
       cleaner call to the parser...)

	[return addresses] = [storybook file size];
	[conditional levels] = zero;

      (clean up variables used by the parser to match player answers against conditions)

	[words in answer] = zero;
	[answer rejected] = no;

      (now A takes the address, within the storybook's executable version held by "storybook
       symbolic contents", of the first instruction of the subroutine to call; B takes value
       1 to indicate that there is 1 saved return address for the parser to return to upon
       meeting a DONE statement, and D takes zero to mean that the parser is executing outside
       of any conditional blocks: that's always correct, because it isn't possible to declare
       labels, ie. "bookmarks", inside IF...FI and similar conditional blocks)

	a = [a plus reference layer];
	b = 1;
	d = zero;

      (at this point, the storybook parser is called throught an alternative entry point,
       which accepts registers A, B and D as they are, rather than setting them up for
       parsing the storybook starting at its first instruction, as it would be normally
       supposed to do...)

	=> push to clause entry;

      (execute the main loop also from its alternative entry point, so that it won't clear
       eventual messages, left by the subroutine, from the display, but still will tell the
       parser to re-parse all of the storybook's code, as if a move was done: display output
       from the storybook at that point, will be appended to eventual messages and pictures
       displayed by the subroutine that was associated with the PUSH...TO clickable span.)

	-> main loop after push to clause;

      (when an answer didn't match at least one condition in the storybook, the mouse pointer
       is replaced by the "what cursor", ideally being the pointer with a question mark, and
       that cursor won't go away until the mouse isn't moved at least 4 pixels away from the
       location where the program placed it... well, the distance traveled is calculated with
       a cheap sum of absolute values, rather than as the geometric distance...  but for four
       pixels who cares? the code's more compact this way...)

      "not released after pushing"
      "not hovering pushable area"
	a = [pointer x coordinate];
	b = [pointer y coordinate];
	a - [what cursor x];
	b - [what cursor y];
	| a |;
	| b |;
	a + b;

      (if at least 4 pixels away from the original location of the "what cursor" hotspot,
       turn off "what cursor" by clearing its flag: above code at "out of pushable areas"
       will realize it, and set back [pointer to arrow shape] to "norm cursor shape"...)

      ? a < 4 -> control keyboard;
	[what cursor active] = no;

      (after checking mouse pointer stuff, check keyboard input: if iGUI doesn't reserve the
       keyboard for itself, at the moment, retrieve console input and, if any keystroke is
       read, react to the keystroke by updating the answer prompt line; the iGUI monopolyzes
       the keyboard while a file selector's filename field is in show: iGUI clients shouldn't
       interfere with keyboard input at that point. If the program used "get console input"
       even while the iGUI is doing the same with its filename field, keystrokes would be read
       in two different points of this application, whichever comes first, but that wouldn't
       be right. In theory, by extending functionalities of the "ekey" library and using only
       hardware scancodes to manage your own keyboard driver with multiple circular buffers,
       you could then modify this program and the iGUI to avoid such a conflict, but still,
       both pieces of code, each reading in that case from its "personal" keyboard buffer,
       would both react to a single keystroke, and that'd be quite confusing for the user, to
       see he/she's writing in two places with one keyboard... I'm saying this to point out
       that there probably isn't a better way to solve this point: one keyboard, one buffer,
       so one focused input field at a time.)

      "control keyboard"
      ? [client owns text cursor] = no -> end of control loop;
	[console command] = get console input;
	isocall;
      ? failed -> end of control loop; (no keystroke to read from keyboard circular buffer)

      (remove "what cursor" while editing the answer prompt line)

	[answer rejected] = no;

      (if keystroke is "enter", ASCII code 13, go to "parse players answer",
       if it's "backspace", ASCII code 8, go to "backspace first control")

      ? [console input] = 13 -> parse players answer;
      ? [console input] = 8 -> do backspace;

      (if keystroke is out of the standard ASCII range, ignore the keystroke)

      ? [console input] < 32 -> end of control loop;
      ? [console input] > 126 -> end of control loop;

      (if it's ASCII, but you have no room for further characters, ignore it anyway)

      ? [answer length] = max characters in answer -> end of control loop;

      (if it's an uppercase letter, transform it to lowercase)

      ? [console input] > 90 -> lowercase keystroke;
      ? [console input] < 65 -> lowercase keystroke;
	[console input] + 32;

      (add keystroke: increase answer length, store character, append null terminator,
       jump to rewrite the answer, or the animated part of it...)

      "lowercase keystroke"
	a = [answer length];
	[a plus answer buffer] = [console input];
	[a plus answer buffer plus 1] = null;
	[answer length] +;
	-> update answer on screen;

      (backspace one character: decrease length, place null terminator on new end,
       proceed with no jump to the subsequent "update answer on screen"...)

      "do backspace"
      ? [answer length] = 0 -> end of control loop;
	[answer length] -;
	a = [answer length];
	[a plus answer buffer] = null;

      (rewrite actual contents of answer prompt line: either by retracing the whole display or,
       if proper flag set, by retracing only the part, near the text cursor, which might have
       changed in consequence of a keystroke; after a full retrace, the said flag is forcely
       set: unless it gets cleared before next iteration, as for when a move is done, like the
       submission of an answer with <ENTER>, or the clicking of a pushable link, it will remain
       set for the - more frequent - case of one or more subsequent keystrokes...)

      "update answer on screen"
      ? [update only vicinity of cursor] = yes -> update vicinity of cursor;
	[update only vicinity of cursor] = yes;
	=> service display refresh;
	=> update layers;
	-> eventually display what cursor;

      (when updating the display part that's "near" to the cursor, to rewrite part of the text
       and show added/removed characters, and at the same time to display the fact that the
       cursor has moved - right on inserts, left on backspaces - start from the top left corner
       of the actual character below the cursor, ie. of the position in which the text cursor
       WAS located before one character was added/removed, and clip a rectangle relatively to
       those coordinates, starting at -48;-48, ending at +48;+48, assuming that no changed
       pixels should lay outside that area: it may be necessary to enlarge the area, and the
       value of register C in the code that follows, to account for larger text metrics, or if
       a text cursor larger, or more "shifted" in relation to the end of the prompt string, is
       to be used in place of the actual yellow "cresent"...)

      "update vicinity of cursor"
	a = [text cursor x];
	b = [text cursor y];
	c = 48;

      (build cursor's "surroundings" region)

	[left margin relating cursor line] = a;
	[left margin relating cursor line] - c;
	[top margin relating cursor line] = b;
	[top margin relating cursor line] - c;
	a + c;
	b + c;
	[right margin relating cursor line] = a;
	[bottom margin relating cursor line] = b;

      (normalize that region, ie. check that the region's edges are in the right order, that
       the region isn't void, that none of its edges get out of those of the target layer...)

	[region to normalize] = cursor line;
	=> normalize region;

      (copy cursor region from canvas to backdrop, to erase its former contents with those of
       the canvas: the "canvas" is the pure background holding storybook displayed outputs,
       pictures and background details such as the lower-right signature logo...)

	[l2l region] = cursor line;
	[source layer] = canvas layer;
	[destination layer] = backdrop layer;
	=> copy l2l region;

      (trace prompt line over backdrop layer)

	=> retrace prompt line;

      (tell iGUI to update that same area - I'm avoiding to reload [l2l region] = cursor line,
       which however is the entry argument for "update area": this is better than just copying
       with a <[display command] = retrace> with [live region] set to "cursor line", because
       the iGUI does the same AFTER eventually retracing the mouse pointer over that spot: it
       avoids mouse pointer flickering, because the "retrace" command is used after all layers
       have been, to use Photoshop's terminology, "flattened" on one single surface, which is
       then copied as it is...)

	=> update area;

      (this is the end of the control loop: at the end of an iteration, flag [answer rejected]
       is checked, and if found true, the mouse cursor is FORCELY moved to indicate the text
       cursor in the answer prompt line, and its shape changed to "what cursor", a version of
       the pointer's feather that's painted in red and has question marks around, to indicate
       that The Narrator didn't find any conditions matching that answer, in the storybook)

      "eventually display what cursor"
      ? [answer rejected] = no -> end of control loop;

      (turn cursor to "what cursor")

	[what cursor active] = yes;
	[pointer to arrow shape] = what cursor shape;

      (watch this trick: because I know how the RTM works, I'm also confident it's capable of
       forcing a move of the system mouse pointer; when you enter "by delta" mode, the pointer
       gets necessarily clipped to the part of the screen covered by the application's display
       window, but the [pointer x coordinate] and [pointer y coordinate] variables are used
       to preserve the position to which the pointer will have to be moved back after leaving
       "by delta" mode. Knowing that, by altering them "manually" and then leaving "by delta"
       mode, the mouse pointer will be restored to the *altered* coordinates, which, in this
       case, are those of the "what cursor": they're calculated upon writing the prompt line,
       as a position that's slightly to the right of the text cursor's "crescent"...)

	[pointer status] | by delta;
	isocall;

	[pointer x coordinate] = [what cursor x];
	[pointer y coordinate] = [what cursor y];

	[pointer status] & not by delta;
	isocall;

      "end of control loop"
	leave;

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				    STORYBOOK DECOMPRESSOR
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

    "load packaged storybook"

      (sizing "storybook symbolic contents" to hold a max. of "max storybook size" bytes:
       watch carefully for the following operation, it's not immediately comprehensible...)

	[ramtop] = max storybook size asbytesize plus storybook symbolic contents;
	isocall;

      (if memory allocation failed, there's nothing else to do...)

      ? failed -> ls no packaged storybook;

      (store default file checksum only: no former loads are supposed to have happened here)

	[storybook file checksum] = undefined;

      (reading storybook's compressed stream from stock, ie. from the executable program:
       read as much as you can, 'cos the compressed stream is terminated by an EoF code
       insterted somewhere in its LZ dictionary, and it will be found later...)

	[file name] = stockfile;
	[file command] = read;
	[file position] = defstory;
	[block pointer] = storybook symbolic contents;
	[block size] = max storybook size;
	isocall;

      (check if there's a possible packaged storybook: at the beginning of what you've
       just read, there might be a memory unit of unknown value, representing the first
       four bytes of the compressed packaged storybook; if there's no packaged story, the
       four bytes having been read from offset "defstory" of the stockfile, would contain
       the beginning of "build/defstory.txt", which is the plain "@STORY" cookie...)

      ? [storybook symbolic contents] = atstory -> ls no packaged storybook;

      (a compressed storybook might be present: try uncompressing it, from compressed data
       read into "storybook symbolic contents", to ascii buffer "storybook ascii contents")

	[lz datagram] = storybook symbolic contents;
	[lz take bit] = zero;
	[lz wordfill] = zero;
	[lz datasize] = zero;
	[lz chnksize] = 12288;
	[lz data out] = storybook ascii contents;
	[lz give bit] = zero;
	[lz size out] = max storybook size mtp 8;
	=> unlz;

      (if "unlz" failed uncompressing, this was not really a packaged strybook, or the package
       got in some way corrupted: return to main program without validating the storybook...)

      ? failed -> ls no packaged storybook;

      (if "unlz" succeeded with uncompression, now you know the uncompressed size of the story
       as [lz bits out] / 8, and - because of how "unlz" works - also the compressed size that
       is given by [starting bit number] / 8: this last value is important because it marks
       the beginning of the package's components table, which is also compressed... for now,
       memorize [storybook file size]...)

	[storybook file size] = [lz bits out];
	[storybook file size] > 3;

      (at the beginning of the compressed storybook, the original name of the storybook's file,
       without extension, was saved in the package as a null-terminated 4bstring preceeding the
       effective contents of the storybook file: this base name must be recovered to generate
       an appropriate filename for this story's situation file; now, finding the length of the
       story's base file name: if it's zero, or more than 255 characters, it's invalid...)

	[source string] = storybook ascii contents;
	=> strlen;
      ? [string length] = 0 -> ls no packaged storybook;
      ? [string length] > 255 -> ls no packaged storybook;

      (generating situation file name as base name + situations extension)

	[source string] = storybook ascii contents;
	[target string] = storybook situation file;
	=> strcpy;

	[source string] = situations extension;
	[target string] = storybook situation file;
	=> strcat;

      (finding the size, in bytes, of the 4bstring giving the base file name, including its
       null terminator: the whole uncompressed storybook will need to be shifted back by that
       amount of bytes, to overwrite the now-useless base file name, so that it begins exactly
       at the beginning of "storybook ascii contents"...)

	[string length] +;				(count null terminator)
	[string length] < shifts per unit bytes;	(length in bytes = length in units * 4)

      (subtract the amount of bytes to be removed from [storybook file size]...)

	[storybook file size] - [string length];

      (shift back storybook ascii contents by the said amount of bytes, overwriting base name)

	[pb stream] = storybook ascii contents;

	a = zero;
	b = [string length];
	c = [storybook file size];

      "ls remove storybook name"
	[pb offset] = b;
	=> get progressive byte;
	[pb offset] = a;
	=> set progressive byte;
	a +;
	b +;
	c ^ ls remove storybook name;

      (find the size, in bytes, of the compressed storybook stream: after that there's one more
       stream holding the compressed version of the package's components table; give result to
       variable [lz take bit], so it'll be ready for the second call to "unlz"...)

	[lz take bit] = [starting bit number];
	[lz take bit] > 3;
      ? [starting bit number] - 7 -> ls packed size evens;
	[lz take bit] +;

      (uncompress package components table)

      "ls packed size evens"
	[lz datagram] = storybook symbolic contents;
	[lz take bit] < 3;
	[lz wordfill] = zero;
	[lz datasize] = zero;
	[lz chnksize] = 1536;
	[lz data out] = package components table;
	[lz give bit] = zero;
	[lz size out] = 2 mtp max package components mtp cpu unit;
	=> unlz;

      (components table must be here, even if it could be void: if it's not here at all,
       and "unlz" fails in reply, you're compelled to consider the package invalid...)

      ? failed -> ls no packaged storybook;

      (at this point, [starting bit number], having been set from [lz take bit] before the call
       to "unlz" to the size of the compressed storybook file, and having been advanced by the
       "unlz" subroutine until the end of the components' table, gives the size in bits of the
       two compressed parts, storybook and components table: after these parts, component files
       are supposed to be found, so the value of [starting bit number], appropriately converted
       to an amount of bytes, will be taken as the base offset, relative to "defstory", of the
       first component file...)

	[packaged components base offset] = [starting bit number];
	[packaged components base offset] > 3;
      ? [starting bit number] - 7 -> ls base offset evens;
	[packaged components base offset] +;

      (make components' base offset an absolute offset from the beginning of the stockfile)

      "ls base offset evens"
	[packaged components base offset] + defstory;

      (the "offset" field of the first component file, in respect to the beginning of the
       sequence of component files, would obviously ALWAYS be zero, so that 32-bit field was
       instead used, upon packaging, to store the number of files in the package's components
       table: now, get its value as [components table records], and properly set the field back
       to zero, so the offset will be right when the first component file will have to be
       accessed...)

	[components table records] = [package components table];
	[package components table] = zero;

      (if you get this far without errors, the packaged storybook is intact, so you can proceed
       with interpreting its contents, by jumping at "ls packaged entry": also, consolidate the
       flag [packaged storybook present] for the main program to know, point the situation file
       name to the formerly generated name, and install the layout of the application's menu in
       case the program is used to access packaged storybooks...)

	[packaged storybook present] = yes;
	[pointer to situation file name] = storybook situation file;
	[menu to install] = package menu layout;
	=> install menu;
	-> ls packaged entry;

      (if you met an error condition while loading the packaged storybook, return without
       setting the [packaged storybook present] flag to "yes": because this subroutine is
       called at the beginning of the main program, the flag will have been allocated into
       the workspace with a default value of zero, which also means "no"...)

      "ls no packaged storybook"
	leave;

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					STORYBOOK LOADER
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

    "load storybook"

      (clear validation flag and restore file checksum from any eventual former loads...)

	[valid storybook file] = no;
	[storybook file checksum] = undefined;

      (read storybook file from specified place: either a file name, when the pointer isn't
       null, or the application's stockfile, when the pointer is null and "defstory" is used
       as the starting position of the read operation; read as much as the buffer allows...)

	[file name] = [pointer to storybook file name];
	[file command] = read;
	[file position] = [storybook file position];
	[block pointer] = storybook ascii contents;
	[block size] = max storybook size;
	isocall;

      (use the amount of bytes read to mark the effective size, in bytes, of the storybook)

	[storybook file size] = [block size];

      (begin translating from "storybook ascii contents" to "storybook symbolic contents":
       this subroutine is entered here after a packaged storybook has been uncompressed...
       as a first thing, set the window title to "untitled story": eventually, storybooks
       are supposed to change the title using the appropriate TITLE command...)

      "ls packaged entry"
	[window title] = default title string;
	=> update title bar;

      (if storybook is a void file, there's nothing to translate)

      ? [storybook file size] = zero -> ls all done;

      (start by sizing storybook symbolic contents buffer to hold a first span of the
       storybook's loaded version: more spans will be allocated as far as they're needed)

	[ramtop] = storybook symbolic contents plus loader span size;
	isocall;

      ? failed -> ls out of memory;

      (register A is the offset of the destination unit within "storybook symbolic contents",
       register B is used to keep the offset of the bit to read the ascii storybook from: be
       aware that B isn't necessarily A * 8, because all keyword strings that will be found,
       will be stripped to a single unit, holding the corresponding keyword identificator;
       furthermore, the translation involves removal of extra white spaces coming before and
       after keywords: the rule says that there may be a single white space after a keyword,
       but not more than one, and that there might be no white spaces before the next keyword,
       unless white spaces are FORCED into the story's visual output using underscore signs...)

	a = zero;
	b = zero;

      (register D informatively counts how many structural block are open at a given time)

	d = zero;

      (reset all vital flags and counters involved in translation)

	[ls column]		= zero;
	[ls row]		= zero;
	[number of symbols]	= zero; (the amount of declared symbols is zero, now)
	[statement type]	= zero; (no statement has been defined, say zero as convention)
	[disallow text] 	= yes;	(on startup, you're expecting some kind of keyword)
	[saying something]	= no;	(not writing to the display)
	[formerly spaced out]	= no;	(no former whitespaces found)
	[significant text seen] = no;	(no significant characters found)
	[open symbol]		= no;	(not being translating a symbol name)

      (set pointer to bit stream to read from, for "get bit field": the story's ascii buffer)

	[bit stream pointer] = storybook ascii contents;

      (begin translation loop: as a first thing, verify if symbolic contents buffer can hold
       next unit, else try to add one more span, and eventually report a lack of memory...)

      "ls next control block"
	e = [ramtop];
	e - storybook symbolic contents;
      ? a < e -> ls within same span;

	[ramtop] + loader span size;
	isocall;

      ? failed -> ls out of memory;

      (read a single byte to produce checksum hash, then read 32 bits, being four bytes, to
       compare them with the various keywords' identificators declared among the constants...)

      "ls within same span"
	---->;

	[starting bit number] = b;
	[bit field size] = 8;
	=> get bit field;

	a = [bit field content];
	a * 123;
	a & ffh;
	[storybook file checksum] # a;
	[storybook file checksum] @> 8;

	[bit field size] = 32;
	=> get bit field;

	<----;

      (set C to the four bytes read from the storybook, for faster repeated comparisons)

	c = [bit field content];

      (looking for 9-character keywords: should a match be found, [rest of control block now]
       will reflect that, apart from a single character - which means a single unit in the
       symbolic contents buffer, there will be another 8 characters to strip out of the
       translated version of the storybook, being the rest of the keyword...)

	[rest of control block now] = 64;	(64 = 8 characters to strip * 8 bits each)

      ? c = no longer -> ls negation;
      ? c = randomize -> ls symbol declare;

      (looking for 8-character keywords)

	[rest of control block now] = 56;

      ? c = actually -> ls generic;
      ? c = indicate -> ls output;
      ? c = multiply -> ls symbol declare;
      ? c = subtract -> ls symbol declare;

      (looking for 7-character keywords)

	[rest of control block now] = 48;

      ? c = nothing -> ls negation;
      ? c = no more -> ls negation;

      (looking for 6-character keywords)

	[rest of control block now] = 40;

      ? c = atstory -> ls cookie;
      ? c = append -> ls generic;
      ? c = xivide -> ls symbol declare;
      ? c = nobody -> ls negation;
      ? c = please -> ls generic;
      ? c = report -> ls symbol declare;

      (looking for 5-character keywords)

	[rest of control block now] = 32;

      ? c = claim -> ls output;
      ? c = every -> ls block open;
      ? c = epoch -> ls special;
      ? c = input -> ls special;
      ? c = title -> ls output;
      ? c = yreve -> ls block terminator;

      (looking for 4-character keywords)

	[rest of control block now] = 24;

      ? c = done -> ls return point;
      ? c = from -> ls symbol declare after subtraction;
      ? c = note -> ls output;
      ? c = push -> ls output;
      ? c = seed -> ls generic;
      ? c = show -> ls generic;
      ? c = xtop -> ls return point;
      ? c = well -> ls bookmark declare;
      ? c = when -> ls bookmark declare;

      (looking for 3-character keywords: zero most significant byte of C)

	c & ffffffh;
	[rest of control block now] = 16;

      ? c = add -> ls symbol declare;
      ? c = and -> ls conjunction;
      ? c = but -> ls conjunction;
      ? c = not -> ls negation;
      ? c = now -> ls symbol declare;
      ? c = say -> ls output;

      (looking for 2-character keywords: zero 2 most significant bytes of C)

	c & ffffh;
	[rest of control block now] = 8;

      ? c = by -> ls symbol declare after mdr;
      ? c = if -> ls block open;
      ? c = fi -> ls block terminator;
      ? c = or -> ls disjunction;
      ? c = no as string -> ls negation;
      ? c = to -> ls symbol declare after addition;

      (looking for single characters: zero 3 most significant bytes of C)

	c & ffh;
	[rest of control block now] = 0;

      (single characters will be considered plain text if an output operation is in progress,
       ie. if a SAY... command, or an equivalent where the following text counts, has been
       found before getting here: if there's no output in progress, only three arithmetical
       operators will be translated as a particular kind of keyword...)

      ? [saying something] = yes -> ls no control block;
      ? [statement type] = note -> ls no control block;

      ? c = 60 -> ls less than;
      ? c = 61 -> ls equate;
      ? c = 62 -> ls greater than;

	-> ls no control block;

      (on return from translating a keyword, skip any remaining insignificant characters of
       the keyword; then, proceed to update flags, and store keyword identificator held by
       register C into the unit indicated by offset A of "storybook symbolic contents")

      "ls translation done"
	[statement type] = c;			(update last found statement type)

      "ls transparent statement"
	b + [rest of control block now];	(update B as starting bit number to read from)
	e = [rest of control block now];	(reduce file size counter to account for...)
	e > 3;					(...stripped characters, calculating bytes...)
	[storybook file size] - e;		(...to strip as [rest of control block] / 8)

	e +;					(being e = no. of characters following the...)
	[ls column] + e;			(...first keyword's character, update column)

	[symbol code] = zero;			(reset for next symbol code, in any cases)
	[numeric value] = no;			(wait for digits before claiming it's numeric)
	[formerly spaced out] = yes;		(remember to trim subsequent, coupled blanks)
	[significant text seen] = no;		(no significant characters seen after keyword)

      ? c = note -> ls trim notes;			(don't even record the "NOTE" keyword)
	[a relating storybook symbolic contents] = c;	(else, record keyword block as a unit)

	-> ls proceed;

      (if this was no keyword, store single character as it is, unless no text is allowed here)

      "ls no control block"
      ? c > 126 -> ls invalid character;
      ? c >= 32 -> ls single character;
      ? c = 13 -> ls store char;
      ? c = 10 -> ls line feed;
      ? c = 9 -> ls tab code;

      "ls invalid character"
	[message] = invalid character;
	-> load error;

      "ls line feed"
	[ls row] +;
	[ls column] = zero;
	-> ls store char;

      "ls tab code"
	e = [ls column];
	e / [ls tab size];
	e +;
	e * [ls tab size];
	[ls column] = e;
	-> ls store char;

      "ls single character"
	[ls column] +;

      ? c = 32 -> ls store char;

	[significant text seen] = yes;
      ? [disallow text] = no -> ls store char;

	[message] = no text expected here;
	-> load error;

      (cut notes "at the stem": don't bother whatever they say as long as it's no keyword,
       don't send their characters to the symbolic contents buffer, so the parser will not
       even see where notes were...)

      "ls store char"
      ? [statement type] = note -> ls trim notes;

	[a plus storybook symbolic contents] = c;

      (consider that a backslash, code 92, is a forced carriage return in the storybook's
       displayed output: it's to be considered as an alias for a space, so leading blanks
       before the text on the next line will be stripped; apart from that, accept ascii
       codes above 32 as effective characters, while any codes below or equal to 32 will
       be translated as blank spaces, ie. code 32: this equalizes the behavior of tabs,
       line feeds and other insignificant text formatters that the author may have used...)

      ? c = 92 -> ls space alias;
      ? c > 32 -> ls accept character;

      (if a blank space was already found before, strip others eventually following it)

      ? [formerly spaced out] = yes -> ls trim notes;
	[a plus storybook symbolic contents] = 32;

      "ls space alias"
	[formerly spaced out] = yes;
	-> ls proceed;

      (if character code > 32, it breaks the eventual sequence of blanks, so clear the flag...)

      "ls accept character"
	[formerly spaced out] = no;

      (while in a symbol name, calculate symbol name hash)

      ? [open symbol] = no -> ls proceed;

      (for symbol name hash, convert uppercase letters to lowercase, because the symbol name is
       supposed to be case-insensitive, and for the hash, ignore anything outside letters and
       digits ranges: punctuators, especially, which are allowed to improve the readability of
       the storybook's code...)

      ? c <  48 -> ls proceed;	      ( ..... 0 )
      ? c > 122 -> ls proceed;	      ( z ..... )
      ? c >= 97 -> ls add characters; ( a ... z )
      ? c >  90 -> ls proceed;	      ( Z ..... )
      ? c >= 65 -> ls add uppercases; ( A ... Z )
      ? c >  57 -> ls proceed;	      ( 9 ..... )

	[numeric value] = yes;	(set as flag upon meeting digits)
	-> ls add characters;

      "ls add uppercases"
	c + 32;

      "ls add characters"
	c * 123;
	c & ffh;
	[symbol code] # c;
	[symbol code] @> 8;

      (end of translation loop: increase destination offset A, increase starting bit number to
       read the next ascii byte, ie. increase B by 8 bits, and check if the storybook is over)

      "ls proceed"
	a +;
	b + 8;
      ? a < [storybook file size] -> ls next control block;
	leave;

      (end of loop while in a NOTE block, which is barely a comment, so it will not be stored
       in the "symbolic contents" buffer that the parser will subsequently examine...)

      "ls trim notes"
	b + 8;
	[storybook file size] -;
      ? a < [storybook file size] -> ls next control block;

      (end of translation: return to caller)

      "ls all done"
	leave;

      (the loader jumps here when there's not enough memory to hold the translated storybook)

      "ls out of memory"
	[message] = out of memory;
	-> load error;

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					KEYWORD LOADERS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

      (@+STORY validates the storybook, setting corresponding flag to be checked on return
       from the "load storybook" subroutine; it also works as a particular kind of "note",
       and more specifically it can be used as an introductory note...)

      "ls cookie"
      ? [disallow text] = yes -> ls cookie allowed;

	[message] = misplaced cookie;
	-> load error;

      "ls cookie allowed"
      ? [valid storybook file] = no -> ls first cookie;

	[message] = superfluous cookie;
	-> load error;

      "ls first cookie"
	c = note;
	[valid storybook file] = yes;
	-> ls generic;

      (in Narrator's syntax, all keywords terminate the entity that comes before the keyword:
       this is excepted by keyword "NOT", and its synonyms, because they are supposed to be
       placed in the middle of a symbol's name, specifically a "NOW" clause, to negate it, or
       to check negative status in conditional IF...FI blocks...)

      "ls negation"
      ? [statement type] = if -> ls negation allowed;
      ? [statement type] = and -> ls negation allowed;
      ? [statement type] = or -> ls negation allowed;
      ? [statement type] = now -> ls negation allowed;

      "ls negation misplaced"
	[message] = misplaced negation;
	-> load error;

      "ls negation allowed"
	c = not;
	-> ls transparent statement;

      ("AND" has a synonym: "BUT", which is translated to the same identificator as "AND")

      "ls conjunction"
      ? [significant text seen] = no -> ls conjunction misplaced;
      ? [statement type] = if -> ls conjunction allowed;
      ? [statement type] = and -> ls conjunction allowed;
      ? [statement type] = or -> ls conjunction allowed;
      ? [statement type] = lessthan -> ls conjunction allowed;
      ? [statement type] = equate -> ls conjunction allowed;
      ? [statement type] = greaterthan -> ls conjunction allowed;

      "ls conjunction misplaced"
	[message] = misplaced conjunction;
	-> load error;

      "ls conjunction allowed"
	c = and;
	-> ls generic;

      (the only disjunction so far is "OR")

      "ls disjunction"
      ? [significant text seen] = no -> ls disjunction misplaced;
      ? [statement type] = if -> ls generic;
      ? [statement type] = and -> ls generic;
      ? [statement type] = or -> ls generic;
      ? [statement type] = lessthan -> ls generic;
      ? [statement type] = equate -> ls generic;
      ? [statement type] = greaterthan -> ls generic;

      "ls disjunction misplaced"
	[message] = misplaced disjunction;
	-> load error;

      ("INPUT" and "EPOCH" are special symbol names representing interval numeric values:
       if one such keywork is found, it must not be preceeded by anything after last statement,
       and nothing else must be found before the next statement...)

      "ls special"
      ? [statement type] = if -> ls special allowed;
      ? [statement type] = and -> ls special allowed;
      ? [statement type] = or -> ls special allowed;
      ? [statement type] = lessthan -> ls special allowed;
      ? [statement type] = equate -> ls special allowed;
      ? [statement type] = greaterthan -> ls special allowed;
      ? [statement type] = report -> ls special allowed after symbol declare;
      ? [statement type] = seed -> ls special allowed after symbol declare;

	[message] = misplaced keyword;
	-> load error;

      "ls special allowed after symbol declare"
	[numeric value] = yes;

      "ls special allowed"
      ? [significant text seen] = no -> ls special alone;

	[message] = extra chrs before spec;
	-> load error;

      "ls special alone"
	=> ls terminate entity;
	[disallow text] = yes;
	-> ls transparent statement;

      (the following keywords introduce to some kind of display output: they must set a flag,
       to keep the loader from considering < = > operators as effective; also they pratically
       are statements, although a free kind of...)

      "ls output"
	=> ls terminate entity;
	[saying something] = yes;
	-> ls translation done;

      (following keywords are simply translated, but not considered for symbols declaration:
       they are precise kinds of statement, so what follows them will have to deal with rules;
       note that IF... isn't consider for symbols declaration, as an exception, because it can
       be followed by a wordlist to be checked against player's answers, and such a wordlist
       wouldn't have to be considered as a possible new symbol)

      "ls block open"
	d +;
      "ls generic"
	=> ls terminate entity;
	-> ls translation done;

      (these introduce, for sure, a symbol's declaration: a clause, and their symbol will be
       registered with type "symbol" and status "false"; in case the clause is true, the parser
       will correct its status upon finding the keyword again while interpreting the storybook)

      "ls symbol declare after addition" (to)
      ? [statement type] = indicate -> ls generic;
      ? [statement type] = push -> ls generic;
      ? [statement type] = add -> ls symbol declare;
	-> ls misplaced keyword;

      "ls symbol declare after subtraction" (from)
      ? [statement type] = subtract -> ls symbol declare;
	-> ls misplaced keyword;

      "ls symbol declare after mdr" (by)
      ? [statement type] = xivide -> ls symbol declare;
      ? [statement type] = multiply -> ls symbol declare;
      ? [statement type] = randomize -> ls symbol declare;
	-> ls misplaced keyword;

      "ls symbol declare"
	=> ls terminate entity;
	[open symbol] = yes;		(possibly, we're translating a symbol name)
	[symbol type] = symbol; 	(possibly, this symbol will be a clause)
	-> ls translation done;

      "ls misplaced keyword"
	[message] = misplaced keyword;
	-> load error;

      ("when", or its synonym "well", introduces to a bookmark declaration)

      "ls bookmark declare"
      ? d = zero -> ls bookmark allowed;

	[message] = misplaced bookmark;
	-> load error;

      "ls bookmark allowed"
	c = when; (equalize)
	=> ls terminate entity;
	[open symbol] = yes;		(for sure, we're translating a symbol name)
	[symbol type] = bookmark;	(for sure, this symbol will be a bookmark)
	-> ls translation done;

      (translating the three logical operators)

      "ls less than"
	c = lessthan;
	-> ls check operator placement validity;

      "ls equate"
	c = equate;
      ? [statement type] = now -> ls generic;
	-> ls check operator placement validity;

      "ls greater than"
	c = greaterthan;

      "ls check operator placement validity"
      ? [statement type] = if -> ls generic;
      ? [statement type] = and -> ls generic;
      ? [statement type] = or -> ls generic;

	[message] = misplaced operator;
	-> load error;

      (block terminators, "FI", "YREVE", "DONE" and "STOP", will forbid anything that's not a
       keyword, after them, because text between them and the next keyword would make no sense)

      "ls block terminator"
	d -;
      "ls return point"
	=> ls terminate entity;
	[disallow text] = yes;
	-> ls translation done;

      (finding a new keyword and thus terminating a former entity which may be text to display,
       remember to strip, at this point, a possible trailing space found before the keyword,
       and typically not stripped because preceeded by the characters forming the "entity")

      "ls terminate entity"
      ? a = zero -> ls no trail;
      ? [a minus 1 relating storybook symbolic contents] != 32 -> ls no trail;

	a -;
	[storybook file size] -;

      (see if the entity you're terminating was a symbol name: if yes, register it)

      "ls no trail"
      ? [open symbol] = no -> ls no new symbol;
      ? [numeric value] = yes -> ls no new symbol;

      (register it only if the symbol code reflects a significant name)

      ? [symbol code] != zero -> ls register symbol;

	$ + 1; (discard call to "ls terminate entity")
	[message] = void symbol name;
	-> load error;

      (and, register it only if it wasn't registered before, ie. if "find symbol" fails)

      "ls register symbol"
	=> find symbol;
      ? ok -> ls no new symbol;

      (and well, register it only if there's room in the symbols table for one more symbol)

      ? [number of symbols] = max number of symbols -> ls no new symbol;

      (update symbols counter)

	[number of symbols] +;

      (register symbol's data: register E is an offset to next free record, from "find symbol")

	[e relating symbols code] = [symbol code];	(its name's hash)
	[e relating symbols type] = [symbol type];	(its type)

      (clauses will have an initial status of "false", numerically meaning zero)

	[e relating symbols status] = false;

      (if it's a bookmark, use symbol status to preserve the position of the instruction that
       follows them: at this point of the loader's code, the position is given by register A;
       once the parser meets a jump, PLEASE or PUSH...TO..., to this bookmark, it will place
       its instruction pointer to the value recorded here)

      ? [symbol type] != bookmark -> ls no new symbol;

	[e relating symbols status] = a;

      (reset flags, assuming you're not traversing a display output, and no new symbol names:
       eventually, the specific subroutines for particular keywords translation will alter
       the flags to reflect what might be truly happening...)

      "ls no new symbol"
	[saying something] = no;
	[disallow text] = no;
	[open symbol] = no;
	leave;

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					STORYBOOK PARSER
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

    "parse storybook"

      (increase session number to provide a counter for EVERY...YREVE blocks: the storybook is
       in fact re-parsed after every "move" of the player)

	[session number] +;

      (clear the pushable areas' reference layer: the layer features as many columns as the
       application's display, but needs only one row for every possible line of text: clearing
       begins at current cursor's position, supposedly at the very top of the future page, and
       proceeds throught all the rest of the display, setting all points of the reference layer
       to code "nothing to push", which means the area is free from PUSH...TO sequence links)

	a = reference layer;
	b = [caret y];
	b - text top margin;
	b / text line spacing;
	b + [caret x];
	c = constant width mtp maximum lines;
	c - b;

      "ps clear reference layer"
	[a] = nothing to push;
	a +;
	c ^ ps clear reference layer;

      (if there's nothing to parse, don't even attempt to read the first unit of storybook's
       symbolic contents buffer, because the first unit may not have been properly filled: it
       can happen when the storybook is formed by the sole @STORY cookie, plus some subsequent
       comments, but no "real" contents, because @STORY and comments are trimmed from the file)

      ? [storybook file size] = zero -> ps break parser;

      (set register A as the offset to currently parsed unit of "storybook symbolic contents",
       set register B as the current session's "top of stack": when zero, no stacked returns,
       set register D as the current conditional block nidification level: 0 = main flow...)

	a = zero;
	b = zero;

      (when a subroutine was called via a mouse click on a pushable area, the parser re-enters
       at this point to parse the pushable area's target subroutine: above initialization code
       is inappropriate in such cases because it would put the top of the stack to zero, while
       the top of the stack is supposed to hold, after pushing an area, and upon executing its
       management subroutine, 1 return address, being the address of the end of the storybook,
       in turn causing the whole storybook to be re-parsed as soon as that subroutine returns)

      "push to clause entry"
	d = zero;
	[last true level] = d; (main flow, being level zero, is always under true condition)

      (load C with storybook unit at offset A, just like "ps next code" does: thanks to this
       small piece of redundant code, it then jumps to "ps reset to neutral" to avoid having
       much more redundant code in the form of the many flags' assignments that follow that
       label... I care quite much for the compactness of Narrator's executable file, so much
       that I'm valuing apparent complications like this one, as long as they can cut bytes)

	c = [a plus storybook symbolic contents];
	-> ps reset to neutral;

      (begin parser loop: load current unit into register C, for faster multiple checks)

      "ps next code"
	c = [a plus storybook symbolic contents];

      ? c = epoch -> ps parse epoch;
      ? c = input -> ps parse input;
      ? c = not -> ps parse not;
      ? c = equate -> ps parse equate;
      ? c = lessthan -> ps parse ALop;
      ? c = greaterthan -> ps parse ALop;

      ? [open assignment] = no -> ps ignore subsidiary equates;
      ? c = by -> ps parse equate;
      ? c = to -> ps parse equate;
      ? c = from -> ps parse equate;

      "ps ignore subsidiary equates"
      ? c < 127 -> ps parse text;

      ? [open assignment]	= yes -> ps terminating assignment;
      ? [open condition]	= yes -> ps terminating condition;
      ? [open jump]		= yes -> ps terminating jump;
      ? [open report]		= yes -> ps terminating report;
      ? [open seeding]		= yes -> ps terminating seeding;

      "ps reset to neutral"
	[saying something]	= no;	(reset to neutral: no visual output)
	[open symbol]		= no;	(reset to neutral: not parsing throught a symbol name)
	[open assignment]	= no;	(reset to neutral: no clause value assignment to do)
	[open condition]	= no;	(reset to neutral: no condition string is open)
	[open jump]		= no;	(reset to neutral: no jump to do)
	[open push]		= no;	(reset to neutral: not parsing between PUSH and TO)
	[open report]		= no;	(reset to neutral: no clause value report to do)
	[open seeding]		= no;	(reset to neutral: won't initialize PRNG with seed)
	[operator]		= no;	(reset to neutral: no A/L operator found)

      ? c = if -> ps parse if;
      ? c = fi -> ps parse fi;
      ? c = or -> ps parse or;
      ? c = every -> ps parse every;
      ? c = yreve -> ps parse fi;

      (now see if the parser is following code inside a false conditional block:
       if it is, no subsequent commands must be executed...)

      ? d > [last true level] -> ps parse complete; (to the end of parser loop)

      (parse effective commands: try to check them in an order that might go from the most
       frequently used to the least frequently used, for an easy, small performace boost...)

      ? c = say -> ps parse say;
      ? c = now -> ps parse now;
      ? c = done -> ps parse done;
      ? c = and -> ps parse and;
      ? c = when -> ps parse complete;
      ? c = please -> ps parse please;
      ? c = claim -> ps parse claim;
      ? c = report -> ps parse report;
      ? c = push -> ps parse push;
      ? c = indicate -> ps parse indicate;
      ? c = to -> ps parse to;
      ? c = title -> ps parse title;
      ? c = show -> ps parse show;
      ? c = append -> ps parse append;
      ? c = add -> ps parse add;
      ? c = subtract -> ps parse subtract;
      ? c = multiply -> ps parse multiply;
      ? c = xivide -> ps parse xivide;
      ? c = randomize -> ps parse randomize;
      ? c = actually -> ps parse actually;
      ? c = seed -> ps parse seed;
      ? c = xtop -> ps break parser;

      (if you're not following a command that directs text to the display, such as "SAY",
       "CLAIM", or "PUSH", don't write out whatever character has been found here...)

      "ps parse text"
      ? [saying something] = no -> ps do not write that;

      (while writing, consider blank spaces, forced carriage returns, and forced spaces,
       as all entities that could be used to place an "anchor" for later word-wrapping...)

      ? c = 32 -> ps this character can wrap text; (an explicit blank space)
      ? c = 92 -> ps this character can wrap text; (backslash: a forceful carriage return)
      ? c = 95 -> ps this character can wrap text; (underscore: a forceful blank space)

	-> ps this character cannot wrap text;

      (when you found a possible anchor for future word-wrapping, memorize the pointer to
       the word that follows as [pointer to last word], to eventually restart writing from
       there on a new line, and the position of the cursor as [caret x before last word],
       for later using it to erase the part of the word that's been wrapped to next line:
       you will go on writing as normal, only that, in case you'll smash into the display's
       right edge, you will have a way to know how many pixels are to erase so that the last
       word, causing the wrap to happen, gets fully removed from the display)

      "ps this character can wrap text"
	[pointer to last word] = a;
	[caret x before last word] = [caret x];

      (if you've met a backslash, force a carriage return at this point)

      "ps this character cannot wrap text"
      ? c != 92 -> ps this is no backslash;

      (processing carriage return: remember current cursor position for later splitting of
       a pushable area)

	[caret x before split] = [caret x];
	[caret y before split] = [caret y];

      (processing carriage return: advance cursor to next line)

	[caret y] + text line spacing;
	[caret x] = text left margin;
	[caret x before last word] = text left margin;

      (processing carriage return: check if you're placing a newline while a picture is
       being aligned on one side; in particular, you'll have to care for left-aligned
       pictures, which must not be overlapped by the next line of text, so the left-side
       margin for this carriage return will need a correction, in such cases)

      ? [caret y] < [storybook picture top] -> ps check split of pushable area;
      ? [caret y] >= [storybook picture bottom] -> ps check split of pushable area;
      ? [will append] = yes -> ps check split of pushable area;

	[caret x] + [storybook picture width];
	[caret x before last word] + [storybook picture width];

      (processing carriage return: if you're placing it in the middle of a pushable area, split
       the area by erasing the part between the cursor's position before the backslash and the
       new, current cursor's position, being after the carriage return; because the reference
       layer will get filled only after the PUSH...TO target subroutine's address is found, you
       will need marking the split area with a special code, "spliced area", to indicate the
       future filling subroutine that the points of the marked area are not to be filled...)

      "ps check split of pushable area"
      ? [open push] = no -> ps parse complete;
	---->;
	a = [caret y before split];
	a - text top margin;
	a / text line spacing;
	a * constant width;
	a + [caret x before split];
	b = [caret y];
	b - text top margin;
	b / text line spacing;
	b * constant width;
	b + [caret x];
      "ps split pushable area"
	[a relating reference layer] = spliced area;
	a +;
      ? a < b -> ps split pushable area;
	<----;
	-> ps parse complete;

      (processing character to display: begin with saving all registers, and the next unit
       of the storybook, which will be set to null to work as one-character string's null
       terminator for the call to "tga text", effectively writing one char per call, here)

      "ps this is no backslash"
	[a plus 1 relating storybook symbolic contents] -->;
	[a plus 1 relating storybook symbolic contents] = null;

	=> display from actual offset;

	<-- [a plus 1 relating storybook symbolic contents];
	a = [tgat source string];
	a - storybook symbolic contents;
	-> ps parse complete;

      (if not writing things on the display, check if this character is part of a condition,
       and keep track of every word forming the condition, for eventually checking if they
       appear in the player's answer: if not parsing a condition, you still have to go and
       check if it's part of a symbol's name...)

      "ps do not write that"
      ? [open condition] = no -> ps parse symbol;

      (vector "condition word pointers" is sized to hold a max. number of words equal to half
       the constant "max characters in condition", which on itself gives the max. number of
       characters that could form a condition's wordlist; the limits are generous, but anyway,
       the program might check before a buffer overrun occurs: when it does, stop interpreting
       this condition as a possible wordlist, and only consider it a possible symbol; of course
       if the author intended it as a massive wordlist, the parser will malfunction, but given
       the 5000-character limit, this is very unlikely to happen, and after all, I'd prefere to
       keep the parser clean from ugly runtime error messages...)

      ? [condition length] > max characters in condition -> ps parse symbol;

      (parsing words following IF clause: backup C as E before letter case equalization)

	e = c;

      (the percent sign activates specially randomized conditions: must be remembered)

      ? e != 37 -> ps no percent sign;

	[percent found in condition] = yes;

      (checking letters A to Z: send them to lowercase for case-insensitive checks)

      "ps no percent sign"
      ? e < 65 -> ps no uppercase letter;
      ? e > 90 -> ps no uppercase letter;

	e + 32;
	-> ps still same word;

      (the following characters will not be interpreted as words delimiters)

      "ps no uppercase letter"
      ? e = 47 -> ps still same word;	(forward slash: allows synonyms for an answer's word)
      ? e = 39 -> ps still same word;	(single quote: interpreted as genitive)
      ? e = 34 -> ps still same word;	(double quote: will be ignored)
      ? e = 45 -> ps still same word;	(dash: used in composite words, ie. "semi-lit")
      ? e = 96 -> ps still same word;	(backquote: italians approximate terminal accents)

      (checking letters a to z: allowed in conditions' wordlists)

      ? e < 97 -> ps check numbers now;
      ? e <= 122 -> ps still same word;

      (checking numbers 0 to 9: allowed in conditions' wordlists)

      "ps check numbers now"
      ? e < 48 -> ps found separator;
      ? e <= 57 -> ps still same word;

      (anything else is interpreted as a separator, a punctuator between condition's words;
       flag [concrete new word] results true if at least one significant character, not being
       a blank space, was found between the previous punctuator and this one: if there was such
       a character, the program will register the new word from [previous word pointer], else
       it will proceed to examine the next character, in next parser loop's iteration...)

      "ps found separator"
      ? [concrete new word] = false -> ps parse symbol;

      (register this word from where it begun - [previous word pointer] - and increase words
       counter for this whole condition's wordlist...)

	e = [words in condition];
	[words in condition] +;

	[e relating condition word pointers] = [previous word pointer];
	[e relating condition word pointers] + condition contents;

      (increase internal condition's wordlist chars counter [condition length], then use the
       actual value of the counter to mark the beginning of an eventual, future word: because
       the new word's pointer is marked after increasing [condition length], it will properly
       skip the punctuator that caused the program to register this word, and leave the null
       code at the end of every word as it was pushed there by the code that follows...)

	[condition length] +;
	[previous word pointer] = [condition length];

      (reset [concrete new word] flag: will stay false until significant characters are found)

	[concrete new word] = false;
	-> ps parse symbol;

      (if it's no separator, it can be the beginning of a new word, or the Nth character of a
       present word that still waits to be registered: it will be registered when it's over...)

      "ps still same word"
	[concrete new word] = true;

      (copy from storybook's symbolic contents buffer to a specific buffer for present word:
       push a null character in front of the actual word buffer so every single word looks
       and feels like a null-terminated string... oh, I have the actual character to append
       to this word's string presently loaded in register E and already equalized to lowercase:
       I'd better push it up on the stack and use the stack to hold it while setting E to the
       destination offset of the character to save, then I'll pop it there...)

	e -->;
	e = [condition length];
	<-- [e relating condition contents];

	[e plus 1 relating condition contents] = null;
	[condition length] +;

      (wether the text you're parsing is part of a condition or not, keep calculating the hash
       of this string: the string's hash was basically started last time [symbol code] was set
       to zero; the validity of [symbol code] depends, however, on [open symbol], so its value
       gets reset to zero only if it's really necessary, ie. while [open symbol] = yes...)

      "ps parse symbol"
      ? [open symbol] = no -> ps parse complete;

      ? c <  48 -> ps parse complete; ( ..... 0 )
      ? c > 122 -> ps parse complete; ( z ..... )
      ? c >= 97 -> ps add characters; ( a ... z )
      ? c >  90 -> ps parse complete; ( z ..... )
      ? c >= 65 -> ps add uppercases; ( a ... z )
      ? c >  57 -> ps parse complete; ( 9 ..... )

      (when you meet digits in a symbol name span, a symbol name span being the span of text
       analyzed while flag [open symbol] is true/has a value of "yes", convert each digit to
       its corresponding numeric value, being 0 to 9, and decimally accumulate it to "build"
       up variable [numeric value]: that will be, when the span is over, a number between zero
       and 100 millions, 100 millions being the maximum value to which a Narrator's symbol can
       be set, or checked against... the process to build up the final value might be obvious:
       the actual [numeric value] is multiplied by 10 every time a new digit must be "added",
       then the actual digit is effectively added to the [numeric value], and finally, [numeric
       value] is checked against the 100-million "ceiling" of the range...)

	e = c;
	e - 48;

	[numeric value] * 10;
	[numeric value] + e;
      ? [numeric value] < 100 000 000 -> ps add characters;
	[numeric value] = 100 000 000;
	-> ps add characters;

      (even in symbol names, letters case is ignored: they all are sent to lowercase)

      "ps add uppercases"
	c + 32;

      (symbol name hash calculation...)

      "ps add characters"
	c * 123;
	c & ffh;
	[symbol code] # c;
	[symbol code] @> 8;

      (end of parser loop: advance offset A to next unit of "storybook symbolic contents",
       and check if you're at the end of the translated version of the file: if the end is
       reached, prepare a few variables for the story control loop to deal with, and return)

      "ps parse complete"
      ? [key escape] = on -> ps user break;

	a +;
      ? a < [storybook file size] -> ps next code;

      "ps break parser"
	[answer numeric value] = zero;
	leave;

      "ps user break"
	[message] = parser interrupted;
	=> load error;
	-> parse storybook;

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				KEYWORD PARSERS: REPEATED STEPS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

      (repeated step: upon meeting a keyword that introduces to a condition,
       the parameters for the condition's behavior are reset by calling this subroutine:
       the tree-like view of the flags highlights their dependencies; level-2 flags and
       counters depend from level-1 flags: level-2 flags and counters are insignificant
       if their "parent" flag is inactive, and will need no reset...)

      "ps setup general condition parameters"
	[open symbol]			= yes;	(conditions introduce to checks on symbols)
	  [symbol code] 		= zero; (so reset the symbol code hash's accumulator)
	  [numeric value]		= zero; (and begin with symbol's numeric value of zero)
	[open condition]		= yes;	(that's it)
	  [negation]			= no;	(so far, no "NOT" keyword found)
	  [words in condition]		= zero; (for now, but the parser's loop will update it)
	  [concrete new word]		= no;	(for now: gets true upon meeting first char.)
	  [previous word pointer]	= zero; (first word is at beginning of condition)
	  [condition length]		= zero; (the condition string is void, now)
	  [percent found in condition]	= no;	(until proven there's a percent, by the parser)
	leave;

      "ps setup assignment"
	[open symbol]		= yes;
	  [symbol code] 	= zero;
	  [numeric value]	= zero;
	[open assignment]	= yes;
	  [operation]		= e;
	  [negation]		= false;
	-> ps parse complete;

      "ps setup output"
	[saying something] = yes;
	[pointer to last word] = a;
	[caret x before last word] = [caret x];
	-> ps parse complete;

      "ps setup jump"
	[open jump] = yes;
	[open symbol] = yes;
	[symbol code] = zero;
	[numeric value] = zero;
	-> ps parse complete;

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			    KEYWORD PARSERS: UNCONDITIONED KEYWORDS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

      (keyword "NOT" sets a flag, [negation], that reverses the result of a comparison,
       or, used in conjunction to "NOW", asserts a false clause: notice that the flag isn't
       xored with "true", only assigned: this means two negations will keep negating, for a
       precise choice...)

      "ps parse not"
	[negation] = true;
	-> ps parse complete;

      ("EPOCH" is a special symbol: when it's found, sets current symbol's numeric value to
       the value resulting from the actual number of seconds since the beginning of the year,
       ie. since midnight of January 1st of the current year; it's supposed to be used to have
       real-time seasons in games, or to seed the random number generator back to its intended
       random seed, after a SEED command. The calendar is simplified: months all have 31 days,
       and Universal Time Coordinated is used instead of local time, in spite of time zones.)

      "ps parse epoch"
	=> get epoch;
	[numeric value] = e;
	-> ps parse complete;

      ("get epoch" is a standalone subroutine because it's also called to set the first random
       seed value for the PRNG, when the program starts up, so it's coherent with an eventual,
       initial attempt to execute a "SEED EPOCH"...)

      "get epoch"
	[timer command] = read utc time;
	isocall;
	e = [month];
	e * 31;
	e + [day];
	e * 24;
	e + [hour];
	e * 60;
	e + [minute];
	e * 60;
	e + [second];
	leave;

      ("INPUT" is a special symbol: when it's found, sets current symbol's numeric value to
       the value resulting from the player's answer; if the answer contains no digits, its
       numeric value results zero)

      "ps parse input"
	[numeric value] = [answer numeric value];
	-> ps parse complete;

      "ps parse equate"
	c = equate;

      "ps parse ALop"
	[operator] = c;
	[leftside negation] = [negation];
	[leftside symbol code] = [symbol code];
	[leftside numeric value] = [numeric value];
	[negation] = false;
	[symbol code] = zero;
	[numeric value] = zero;
	-> ps parse complete;

      ("IF" is one of the keywords that need to be parsed even when they appear in a block
       that's not being really executed because under a false chain of previous conditions:
       it must be parsed exactly to keep track of how many nidified blocks form the chain,
       which is being tracked by register D: this register increments when an "IF"/"EVERY"
       keyword is found, and decrements when an "FI"/"YREVE" keyword is found; the value of
       [last true level] indicates which is the last level of the chain holding instructions
       that are placed under a set of true conditions; however, [last true level] gets updated
       upon findind the keyword that terminates the string giving the conditions after a former
       "IF": so, the check D vs. [last true level] must be performed before taking action...)

      "ps parse if"
      ? d > [last true level] -> ps if under false condition;
	=> ps setup general condition parameters;
	[condition type] = if;
      "ps if under false condition"
	d +;
	-> ps parse complete;

      "ps parse or"
	e = d;
	e -;
      ? e > [last true level] -> ps parse complete;
	=> ps setup general condition parameters;
	[condition type] = if;
	-> ps parse complete;

      "ps parse fi"
      ? d > [last true level] -> ps fi under false condition;
	[last true level] -;
      "ps fi under false condition"
	d -;
	-> ps parse complete;

      "ps parse every"
      ? d > [last true level] -> ps every under false condition;
	=> ps setup general condition parameters;
	[condition type] = every;
      "ps every under false condition"
	d +;
	-> ps parse complete;

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			       KEYWORD PARSERS: TWO-STEP KEYWORDS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

      "ps parse and"
	=> ps setup general condition parameters;
	[condition type] = if;
	[last true level] -;
	-> ps parse complete;

      "ps parse now"
	e = equate;
	-> ps setup assignment;

      "ps parse add"
	e = addition;
	-> ps setup assignment;

      "ps parse subtract"
	e = subtraction;
	-> ps setup assignment;

      "ps parse multiply"
	e = multiplication;
	-> ps setup assignment;

      "ps parse xivide"
	e = xivision;
	-> ps setup assignment;

      "ps parse randomize"
	e = randomization;
	-> ps setup assignment;

      "ps parse say"
	[open claim] = no;
	-> ps setup output;

      "ps parse claim"
	[open claim] = yes;
	-> ps setup output;

      "ps parse please"
	[jump type] = please;
	-> ps setup jump;

      "ps parse actually"
	[jump type] = actually;
	-> ps setup jump;

      "ps parse push"
	[feat push] = no;
      "ps setup push"
	[open push] = yes;
	[push starting point] = [caret y];
	[push starting point] - text top margin;
	[push starting point] / text line spacing;
	[push starting point] * constant width;
	[push starting point] + [caret x];
	-> ps setup output;

      "ps parse indicate"
	[feat push] = yes;
	-> ps setup push;

      "ps parse to"
	[push ending point] = [caret y];
	[push ending point] - text top margin;
	[push ending point] / text line spacing;
	[push ending point] * constant width;
	[push ending point] + [caret x];
	[jump type] = to;
	-> ps setup jump;

      "ps parse report"
	[open report]		= yes;
	[open symbol]		= yes;
	  [symbol code] 	= zero;
	  [numeric value]	= zero;
	-> ps parse complete;

      "ps parse seed"
	[open seeding]		= yes;
	[open symbol]		= yes;
	  [symbol code] 	= zero;
	  [numeric value]	= zero;
	-> ps parse complete;

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			       KEYWORD PARSERS: ONE-STEP KEYWORDS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

      "ps parse done"
      ? b = zero -> ps parse complete;
	b -;
	a = [b plus return addresses];
	a -;
	d = [b plus conditional levels];
	[last true level] = d;
	-> ps parse complete;

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				   KEYWORD PARSERS: "TITLE"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

      "ps parse title"
	---->;
	a +; (skip TITLE)
	b = current title;
	[window title] = b;
      "ps find endoftitle"
	c = [a relating storybook symbolic contents];
	a +;
      ? c > 126 -> ps endoftitle;
      ? a = [storybook file size] -> ps endoftitle;
	[b] = c;
	b +;
	-> ps find endoftitle;
      "ps endoftitle"
	[b] = null;
	=> update title bar;
	<----;
	-> ps parse complete;

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			      KEYWORD PARSERS: "SHOW" / "APPEND"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

      "ps parse show"
	[will append] = no;

      "ps show entry"
	---->;
	a +; (skip SHOW/APPEND)
      ? [packaged storybook present] = no -> ps load from file;
	b = zero;
      "rp generate picture name hash"
	c = [a relating storybook symbolic contents];
	a +;
      ? c > 126 -> rp hash completed;
      ? a = [storybook file size] -> rp hash completed;
      ? c < 65 -> rp picture name letter isnt uppercase;
      ? c > 90 -> rp picture name letter isnt uppercase;
	c + 32;
      "rp picture name letter isnt uppercase"
	c * 123;
	c & ffh;
	b # c;
	b @> 8;
	-> rp generate picture name hash;
      "rp hash completed"
	a = package components table;
	c = [components table records];
      ? c = zero -> rp no picture;
      "rp find matching file offset"
      ? [a plus 1] = b -> rp found matching file offset;
	a + 2;
	c ^ rp find matching file offset;
	-> rp no picture;
      "rp found matching file offset"
	[file command] = read;
	[file name] = stockfile;
	[file position] = [a];
	[file position] + [packaged components base offset];
	[block pointer] = picture layer;
	[block size] = pxsize mtp bytes per unit;
	isocall;
      ? failed -> rp no picture;
	-> rp loaded from package;
      "ps load from file"
	[source string] = [pointer to storybook file name];
	[target string] = storybook picture file;
	=> strcpy;
	[source string] = storybook picture file;
	[target string] = stories extension;
	=> strstr;
	[source string] = package files path;
	=> dsexpand;
	[source string] = storybook picture file;
	=> strlen;
	b = [string length];
      "ps copy picture name"
	c = [a relating storybook symbolic contents];
	a +;
      ? c > 126 -> ps copied picture name;
      ? a = [storybook file size] -> ps copied picture name;
      ? c < 65 -> ps picture name letter isnt uppercase;
      ? c > 90 -> ps picture name letter isnt uppercase;
	c + 32;
      "ps picture name letter isnt uppercase"
	[b relating storybook picture file] = c;
	b +;
	-> ps copy picture name;
      "ps copied picture name"
	[b relating storybook picture file] = null;
	[source string] = plz extension;
	[target string] = storybook picture file;
	=> strcat;
	[file command] = test;
	[file name] = storybook picture file;
	isocall;
      ? failed -> rp no picture;
      ? [file size] > pxsize mtp bytes per unit -> rp no picture;
	[file command] = read;
	[file name] = storybook picture file;
	[file position] = zero;
	[block pointer] = picture layer;
	[block size] = [file size];
	isocall;
      ? failed -> rp no picture;
      "rp loaded from package"
	[tga picture data] = picture layer;
	[tga target layer] = canvas layer;
	[tga display alignment] = [display width];
	[tga display height] = [display height];
	[tga effect] = service fx null;
	[lplz draw picture] = yes;
	=> load photolz;
      ? failed -> rp no picture;
      ? [caret x] = text left margin -> rp no line feed;
	[caret y] + text line spacing;
      "rp no line feed"
      ? [storybook picture bottom] < [caret y] -> rp caret not overlapping former picture;
	[caret y] = [storybook picture bottom];
	[caret y] + text line spacing minus text font body;
	a = [caret y];
	a - text top margin;
	a % text line spacing;
      ? a = zero -> rp caret not overlapping former picture;
	[caret y] + text line spacing;
	[caret y] - a;
      "rp caret not overlapping former picture"
	[caret x] = text left margin;
	[caret x before last word] = text left margin;
	[storybook picture width] = [ltp pixels];
	[storybook picture width] + text left margin;
	[storybook picture top] = [caret y];
	[storybook picture bottom] = [caret y];
	[storybook picture bottom] + [ltp scanlines];
      ? [will append] = yes -> rp align to right side j1;
	[caret x] + [ltp pixels];
	[caret x] + text left margin;
	[caret x before last word] + [ltp pixels];
	[caret x before last word] + text left margin;
      "rp align to right side j1"
	a = text line spacing minus 1;
	b = [ltp scanlines];
	b % text line spacing;
	a - b;
	a > 1;
      ? a = zero -> rp no drift;
	a -;
      "rp no drift"
	[storybook picture bottom] + a;
      ? [will append] = yes -> rp align to right side j2;
	[storybook picture width] + a;
	[storybook picture width] + a;
	[caret x] + a;
	[caret x] + a;
	[caret x before last word] + a;
	[caret x before last word] + a;
	[tga picture left] = text left margin;
	[tga picture left] + a;
	-> rp aligned to left side;
      "rp align to right side j2"
	[tga picture left] = [display width];
	[tga picture left] -;
	[tga picture left] - [storybook picture width];
	[tga picture left] - a;
	[storybook picture left] = [tga picture left];
	[storybook picture left] -;
      "rp aligned to left side"
	[tga picture data] = picture layer;
	[tga target layer] = canvas layer;
	[tga display alignment] = [display width];
	[tga display height] = [display height];
	[tga picture top] = [caret y];
	[tga picture top] + a;
	[tga effect] = service fx raw;
	[lplz draw picture] = yes;
	=> load photolz;
	<----;
	[pointer to last word] = a;
	-> ps parse complete;
      "rp no picture"
	<----;
	[storybook picture top] = 0;
	[storybook picture bottom] = 0;
	-> ps parse complete;

      "ps parse append"
	[will append] = yes;
	-> ps show entry;

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		    KEYWORD PARSERS: TWO-STEP KEYWORD EXECUTION: CONDITIONS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

      "ps terminating condition"
      ? [concrete new word] = false -> ps no concrete final word;

	e = [words in condition];
	[words in condition]+;

	[e plus condition word pointers] = [previous word pointer];
	[e plus condition word pointers] + condition contents;

      "ps no concrete final word"
	[condition status] = false;

      ? [condition type] = every -> ps every condition;
      ? [percent found in condition] = yes -> ps randomized condition;
      ? [operator] = no -> ps condition is no comparison;

	=> find symbol;
      ? failed -> ps compare against numeric value;
      ? [e relating symbols type] = bookmark -> ps update condition status;

	[ps auxiliary] = [e plus symbols status];
	-> ps compare against rightside operand;

      "ps compare against numeric value"
	[ps auxiliary] = [numeric value];

      "ps compare against rightside operand"
	[symbol code] = [leftside symbol code];
	=> find symbol;
      ? failed -> ps update condition status;
      ? [e plus symbols type] != symbol -> ps update condition status;

      ? [operator] = lessthan -> ps check lessthan;
      ? [operator] = greaterthan -> ps check greaterthan;

      ? [e plus symbols status] != [ps auxiliary] -> ps finalize comparison;
	[condition status] = true;
	-> ps finalize comparison;

      "ps check lessthan"
      ? [e plus symbols status] >= [ps auxiliary] -> ps finalize comparison;
	[condition status] = true;
	-> ps finalize comparison;

      "ps check greaterthan"
      ? [e plus symbols status] <= [ps auxiliary] -> ps finalize comparison;
	[condition status] = true;

      "ps finalize comparison"
	[condition status] # [leftside negation];
	-> ps update condition status;

      "ps condition is no comparison"
	=> find symbol;
      ? failed -> ps symbol not found so checking player answer;
      ? [e plus symbols type] != symbol -> ps update condition status;

	[condition status] = [e plus symbols status];
      ? [condition status] <= 1 -> ps report boolean status;
	[condition status] = 1;

      "ps report boolean status"
	[condition status] # [negation];

      "ps update condition status"
      ? [condition status] = false -> ps reset to neutral;
	[last true level] = d;
	-> ps reset to neutral;

      "ps symbol not found so checking player answer"
	=> check wordlist condition;
	-> ps update condition status;

      "ps every condition"
      ? [numeric value] = zero -> ps update condition status;
	e = [session number];
	e % [numeric value];
      ? e > zero -> ps update condition status;
	[condition status] = true;
	-> ps report boolean status;

      "ps randomized condition"
	---->;
	=> generate real rnd;
	<----;
	[rnd] ** 100f;
	[rnd] =, [rnd];
      ? [rnd] > [numeric value] -> ps report boolean status;
	[condition status] = true;
	-> ps report boolean status;

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	    KEYWORD PARSERS: TWO-STEP KEYWORD EXECUTION: ASSIGNMENTS AND ASSERTIONS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

      "ps terminating assignment"
      ? [operator] = no -> ps assert clause;
      ? [operator] = equate -> ps assign value;
	-> ps reset to neutral;

      "ps assign value"
      ? [leftside negation] = yes -> ps reset to neutral;
      ? [negation] = yes -> ps reset to neutral;

	=> find symbol;
      ? failed -> ps assign to numeric value;
      ? [e plus symbols type] != symbol -> ps reset to neutral;

	[ps auxiliary] = [e plus symbols status];
	[ps aux offset] = e;
	-> ps assign to rightside symbol status;

      "ps assign to numeric value"
	[ps auxiliary] = [numeric value];
	[ps aux offset] = minus 1;
      ? [operation] = addition -> ps reset to neutral;
      ? [operation] = subtraction -> ps reset to neutral;

      "ps assign to rightside symbol status"
	[symbol code] = [leftside symbol code];
	=> find symbol;
      ? failed -> ps numeric leftside operand;
      ? [e plus symbols type] != symbol -> ps reset to neutral;
	-> ps symbolic leftside operand;

      "ps numeric leftside operand"
	e = [ps aux offset];
      ? e = minus 1 -> ps reset to neutral;
	[ps auxiliary] = [leftside numeric value];
      ? [operation] = addition -> ps perform addition;
      ? [operation] = subtraction -> ps perform subtraction;
	-> ps reset to neutral;

      "ps symbolic leftside operand"
      ? [operation] = equate -> ps perform assignment;
      ? [operation] = multiplication -> ps perform multiplication;
      ? [operation] = xivision -> ps perform xivision;
      ? [operation] = randomization -> ps perform randomization;
	[ps auxiliary] = [e plus symbols status];
	e = [ps aux offset];
      ? [operation] = subtraction -> ps perform subtraction;

      "ps perform addition"
	[e plus symbols status] + [ps auxiliary];
      ? [e plus symbols status] > 100 000 000 -> ps approximate infinity;
	-> ps reset to neutral;

      "ps perform subtraction"
	[e plus symbols status] - [ps auxiliary];
      ? [e plus symbols status] < zero -> ps approximate to zero;
	-> ps reset to neutral;

      "ps perform xivision"
      ? [ps auxiliary] = zero -> ps approximate infinity;
	[e plus symbols status] / [ps auxiliary];
	-> ps reset to neutral;

      "ps approximate infinity"
	[e plus symbols status] = 100 000 000;
	-> ps reset to neutral;

      "ps approximate to zero"
	[e plus symbols status] = zero;
	-> ps reset to neutral;

      "ps perform multiplication"
	a -->;
	b -->;
	a ,= [e plus symbols status];
	b ,= [ps auxiliary];
	a ** b;
     ?? a < 100 000 001f -> ps continue multiplication;
	<-- b;
	<-- a;
	-> ps approximate infinity;

      "ps continue multiplication"
	<-- b;
	<-- a;
	[e plus symbols status] * [ps auxiliary];
	-> ps reset to neutral;

      "ps perform randomization"
	[ps auxiliary] ,= [ps auxiliary];
	---->;
	=> generate real rnd;
	<----;
	[rnd] ** [ps auxiliary];
	[e plus symbols status] =, [rnd];
	[e plus symbols status] +;
	-> ps reset to neutral;

      "ps perform assignment"
	[e plus symbols status] = [ps auxiliary];
	-> ps reset to neutral;

      "ps assert clause"
	=> find symbol;
      ? failed -> ps reset to neutral;
      ? [e plus symbols type] != symbol -> ps reset to neutral;
	[e plus symbols status] = true;
	[e plus symbols status] - [negation];
	-> ps reset to neutral;

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		 KEYWORD PARSERS: TWO-STEP KEYWORD EXECUTION: JUMPS AND CALLS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

      "ps terminating jump"
	=> find symbol;
      ? failed -> ps reset to neutral;
      ? [e plus symbols type] != bookmark -> ps reset to neutral;

      ? [jump type] = to -> ps terminating to instruction;
      ? [jump type] = actually -> ps terminating actually instruction;

      ? b = max please calls -> ps break parser;
	[b plus return addresses] = a;
	[b plus conditional levels] = d;
	b +;

      "ps terminating actually instruction"
	a = [e plus symbols status];
	-> push to clause entry;

      "ps terminating to instruction"
	a -->;
	a = [push starting point];
	e = [e plus symbols status];
      "ps fill pushable area"
      ? a >= constant width mtp maximum lines -> ps out of reference layer;
      ? [a plus reference layer] = spliced area -> ps skipping spliced part;
	[a plus reference layer] = e;
      "ps skipping spliced part"
	a +;
      ? a < [push ending point] -> ps fill pushable area;
      "ps out of reference layer"
	<-- a;
	-> ps reset to neutral;


(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		   KEYWORD PARSERS: TWO-STEP KEYWORD EXECUTION: PRNG SEEDING
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

      "ps terminating seeding"
	=> find symbol;
      ? failed -> ps seed numeric value;
      ? [e relating symbols type] = bookmark -> ps reset to neutral;
	[rnd seed] = [e relating symbols status];
	-> ps seed symbol status;
      "ps seed numeric value"
	[rnd seed] = [numeric value];
      "ps seed symbol status"
	---->;
	=> set random seed;
	<----;
	-> ps reset to neutral;

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		   KEYWORD PARSERS: TWO-STEP KEYWORD EXECUTION: VALUE REPORT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

      "ps terminating report"
	=> find symbol;
      ? failed -> ps report numeric value;
      ? [e relating symbols type] = bookmark -> ps reset to neutral;
	[ps auxiliary] = [e relating symbols status];
	-> ps report symbol status;
      "ps report numeric value"
	[ps auxiliary] = [numeric value];
      "ps report symbol status"
	e = 10;
      "ps backup ten units"
	[a relating storybook symbolic contents] -->;
	a +;
	e ^ ps backup ten units;
	a - 10;
	---->;
	b = false;
	c = 100 000 000;
	e = [ps auxiliary];
      ? e > zero -> ps stream value;
	d = 0;
	c = 1;
	-> ps including trailing zero;
      "ps stream value"
	d = e;
	d / c;
      ? b = true -> ps including trailing zero;
      ? d = zero -> ps ignoring leading zero;
	b = true;
      "ps including trailing zero"
	d + 48;
	[a relating storybook symbolic contents] = d;
	[a plus 1 relating storybook symbolic contents] = null;
	d - 48;
	a +;
      "ps ignoring leading zero"
	d * c;
	c / 10;
	e - d;
      ? c >= 1 -> ps stream value;
	<----;
	[open push]  = no;
	[open claim] = no;
	=> display from actual offset;
	a + 10;
	e = 10;
      "ps restore ten units"
	a -;
	<-- [a relating storybook symbolic contents];
	e ^ ps restore ten units;
	-> ps reset to neutral;

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				    LOADER/PARSER UTILITIES
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

    "load error"

      (begin by setting up a predefined symbols table with only 2 symbols: "a" and "b",
       respectively holding the row and column in the storybook's file at which the
       loader has met an error condition that caused it to jump here...)

	[number of symbols] = 2;

	[0 relating symbols code] = 9b000000h;		(hash of "a")
	[0 relating symbols type] = symbol;		(type of "a")
	[0 relating symbols status] = [ls row]; 	(value of "a")
	[0 relating symbols status] +;			(column is internally based at zero)

	[1 relating symbols code] = 16000000h;		(hash of "b")
	[1 relating symbols type] = symbol;		(type of "b")
	[1 relating symbols status] = [ls column];	(value of "b")
	[1 relating symbols status] +;			(row is internally based at zero)

      (now create a predefined storybook file, of course as if it was already translated from
       its ascii representation, and ready to be parsed, by using "load error display pattern"
       as a model for it: the model reports "a" and "b", then opens a "CLAIM" for the message;
       the storybook symbolic contents buffer is guaranteed to provide at least enough space
       for holding a single error message report...)

	a = storybook symbolic contents minus 1;
	b = pragma load error display pattern;

      "copy load error display pattern"
	c = [b]; b +;
	a +; [a] = c;
      ? c != null -> copy load error display pattern;

      (tail the 7-bit packed error message string to the above model)

	[source string] = [message];
	[target string] = a;
	=> dsexpand;

      (find the length of the so-built storybook file, and inform the parser)

	[source string] = storybook symbolic contents;
	=> strlen;
	[storybook file size] = [string length];

      (validate the so-built storybook file, but nullify the situation file name's pointer
       so that no situation will be saved: of course, this is just an error message display)

	[valid storybook file] = yes;
	[pointer to situation file name] = null;

      (expand and use string "LOAD ERROR" as the title of this er... "storybook", then leave)

	[source string] = load error title;
	[target string] = current title;
	=> dsexpand;

	[window title] = current title;
	-> update title bar;

    "find symbol"

      (this subroutine searchs for a symbol hash, entered as [symbol code], into registered
       symbols' tables: if a match is found, returns register E as the offset of the match
       in the tables, and status ok; if no match is found, returns with E=[number of symbols]
       and status failed; if no symbols are registered yet, returns E=0 and status failed)

	e = zero;
      ? [number of symbols] = zero -> symbol not present;

      "search for symbol"
      ? [e plus symbols code] = [symbol code] -> symbol is present;
	e +;
      ? e < [number of symbols] -> search for symbol;

      "symbol not present"
	fail;

      "symbol is present"
	end;

      (the following subroutine is called by the parser to display a single character, by
       tailing the character's shape to the actually displayed output at the actual cursor
       position: it will also perform word-wraps when hitting the right edge of the display,
       and properly align text so that it doesn't overlap eventual pictures being showen at
       the left or right of the textual output; it's also called upon a "REPORT" keyword is
       found and parsed, to stream the number on the display: the actual offset of the string
       to display, which is relative to "storybook symbolic contents", is supposed to be given
       by register A on entry to the subroutine...)

    "display from actual offset"
	---->;

      (select the appearence of this character, basing on which command was used to write it)

	[tgat red reduction] = 1;
	[tgat green reduction] = 1;
	[tgat blue reduction] = 2;
	[tgat effect] = service fx alpha dim;

      ? [open push] = no -> ps write as normal;

	[tgat red reduction] = 0;
	[tgat green reduction] = 0;
	[tgat blue reduction] = 1;

      ? [feat push] = no -> ps write as normal;

	[tgat red reduction] = 1;
	[tgat green reduction] = 0;
	[tgat blue reduction] = 1;

      "ps write as normal"
      ? [open claim] = no -> ps write it white;

	[tgat red reduction] = 3;
	[tgat green reduction] = 1;
	[tgat blue reduction] = 0;

      (send the character to the display at cursor's position)

      "ps write it white"
	[tgat source string] = a;
	[tgat source string] + storybook symbolic contents;
	[tgat target layer] = canvas layer;
	[tgat left margin] = [caret x];
	[tgat top margin] = [caret y];
	=> tga text;

      (update cursor position, which is returned by "tga text", and add "text right margin" to
       the new position: the margin's addition is temporary, for checking against right edges)

	[caret x] = [tgat current left margin];
	[caret x] + text right margin;

      (before checking for a word-wrap, determine as register E the true right edge of the
       display in this point: normally, it will be the right margin of iGUI's "work area", or
       the "client area" of the applcation's window if you prefere, but in case the program is
       writing a line that's supposed to leave space for a certain right-aligned picture, the
       picture's left edge will be the effective edge for the word-wrapper to respect)

	e = [right margin relating vector work area];

      ? [caret y] < [storybook picture top] -> ps check wrap;
      ? [caret y] >= [storybook picture bottom] -> ps check wrap;
      ? [will append] = no -> ps check wrap;
	e = [storybook picture left];

      (if you didn't hit the right edge, proceed as normal on the same line of text)

      "ps check wrap"
      ? [caret x] < e -> ps keep the line;

      (if you DID hit the right edge, proceed with word-wrap: as a first thing,
       erase the last written word from the right part of the current line...)

	[left margin relating eraser bounds] = [caret x before last word];
	[top margin relating eraser bounds] = [caret y];
	[right margin relating eraser bounds] = e;
	[right margin relating eraser bounds] - 3;
	[bottom margin relating eraser bounds] = [caret y];
	[bottom margin relating eraser bounds] + text font body;
	[l2l region] = eraser bounds;
	[l2l region color] = FFFFFFh;
	[destination layer] = canvas layer;
	=> clear l2l region;

      (remember current cursor position for later splitting of a pushable area)

	[caret x before split] = [caret x before last word];
	[caret y before split] = [caret y];

      ([tgat source string] will be used to restore the value of register A, or the offset to
       the next character to be written, before continuing with the parser's loop: in case of
       a word-wrap, [tgat source string] must obviously be updated to indicate that the last
       word needs to be rewritten...)

	[tgat source string] = [pointer to last word];
	[tgat source string] + storybook symbolic contents;

      (advance cursor to next line, considering the possible presence of a left-side picture)

	[caret x before last word] = text left margin;
	[caret x] = text left margin;
	[caret y] + text line spacing;

      ? [caret y] < [storybook picture top] -> ps check pushable area splicing;
      ? [caret y] >= [storybook picture bottom] -> ps check pushable area splicing;
      ? [will append] = yes -> ps check pushable area splicing;

	[caret x] + [storybook picture width];
	[caret x before last word] + [storybook picture width];

      (if you've been doing a word-wrap in the middle of a pushable area, split the area on
       both lines, and forbid clicking on the void pieces left by the wrapped part...)

      "ps check pushable area splicing"
      ? [open push] = no -> ps been wrapping;

	a = [caret y before split];
	a - text top margin;
	a / text line spacing;
	a * constant width;
	a + [caret x before split];
	b = [caret y];
	b - text top margin;
	b / text line spacing;
	b * constant width;
	b + [caret x];

      "ps splice pushable area"
	[a relating reference layer] = spliced area;
	a +;
      ? a < b -> ps splice pushable area;
	-> ps been wrapping;

      (if not been word-wrapping, remove the extra "text right margin" from [caret x],
       formerly used to simplify the checks against the right edge, but now to be removed)

      "ps keep the line"
	[caret x] - text right margin;

      (finished processing character to display: restore registers, restore nullified unit
       that was making a temporary string null-terminator, restore offset A to point the
       next character to be parsed, and re-enter at the bottom of the parser's loop...)

      "ps been wrapping"
	<----;
	leave;

      (following subroutine is called by parser upon meeting a condition string, following an
       IF... statement, that doesn't match any known symbol names, that is no logical check on
       some numeric amount, and is not even some randomized condition like: IF 10%... at that
       point, the parser will call this subroutine to insulate and count every word matching
       the player's answer given throught the prompt line...)

    "check wordlist condition"
	---->;

      (register A marks offset in "condition word pointers", [confirmed words] will count
       how many words match a word in the answer: for the whole condition to match, all
       words in the condition string must be found in the player's answer; the subroutine
       also has to look for slash-delimited synonyms in the condition's wordlist, hence its
       apparent complexity... mmh... well, maybe it really is quite entangled, but that's it)

	a = zero;

	[confirmed words] = zero;
	[condition status] = false;

      ? [words in answer] = zero -> cwc words are not in;

      "cwc outer loop"
	b = zero;

      "cwc inner loop"
	c = [a plus condition word pointers];

      "cwc compare synonym"
	d = [b plus answer word pointers];

      "cwc character loop"
	e = [c];
	c +;
	d +;
      ? e = 47 -> cwc exit character loop;
      ? e = null -> cwc exit character loop;
      ? [d minus 1] = e -> cwc character loop;

      "cwc check if synonym given"
	e = [c];
	c +;
      ? e = 47 -> cwc compare synonym;
      ? e = null -> cwc next word in answer;
	-> cwc check if synonym given;

      "cwc exit character loop"
      ? [d minus 1] = null -> cwc word match;
      ? e = 47 -> cwc compare synonym;
	-> cwc next word in answer;

      "cwc word match"
	[confirmed words] +;
	-> cwc next word in condition;

      "cwc next word in answer"
	b +;
      ? b < [words in answer] -> cwc inner loop;

      "cwc next word in condition"
	a +;
      ? a < [words in condition] -> cwc outer loop;

      ? [confirmed words] < [words in condition] -> cwc words are not in;

	[condition status] = true;
	[answer rejected] = no;

      "cwc words are not in"
	[condition status] # [negation];
	<----;
	leave;

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				     PLAYER ANSWER PARSER
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

      "parse players answer"
	[answer rejected] = yes;		(assume condition matched, until proven false)
	[words in answer] = zero;		(reset words counter)
	[answer numeric value] = zero;		(reset num. value)

      (the following loop primarily makes a backup copy of the answer, before later code will
       insert null terminators after every word of the answer string, splitting it into smaller
       strings; secondarily, "as long as it's here", it scans the answer for digits, and upon
       finding one, evaluates the digit's value and increases [answer numeric value] as an
       accumulator for the overall result of all digits. In practice, at every digit match,
       the accumulator is multiplied by 10 and added the new digit's value: scanning the string
       left-to-right, if it expresses a number in base 10, the number will be finally returned
       as [answer numeric value]. Numeric answers determine the value of the special <INPUT>
       keyword which storybooks may parse when the player is supposed to enter a number along
       with his/her answer... see "samples/narrator's calculator.txt" for such an instance...)

	a = answer buffer;
	b = answer backup buffer;
	c = [answer length];
	c +; (also backup null terminator)

      "ppa backup answer"
	d = [a];
	a +;
      ? d < 48 -> ppa no digit;
      ? d > 57 -> ppa no digit;
	e = d;
	e - 48;
	[answer numeric value] * 10;
	[answer numeric value] + e;
	[answer rejected] = no; (answers holding numbers are always accepted)
      ? [answer numeric value] < 100 000 000 -> ppa no digit;
	[answer numeric value] = 100 000 000;
      "ppa no digit"
	[b] = d;
	b +;
	c ^ ppa backup answer;

      (the loop that follows is similar to the code that splits condition strings in words,
       in the storybook's parser, assuming that every sign that shouldn't be part of a word
       is a punctuator separating it from the next word...)

	a = zero;	(offset in "answer buffer" of currently examined character)
	b = zero;	(n. of words currently found, also offset into "answer word pointers")
	c = zero;	(starting offset of last found word: determines its pointer)
	d = false;	(flag: was any non-punctuator char found after last word's end?)

      (start by loading register E with current char. code for quicker checks,
       increase A to fetch next character, check if the string is over: in later code,
       consider the fact that A will already be one unit after the current character...)

      "ppa next char"
	e = [a plus answer buffer];
	a +;
      ? a > [answer length] -> ppa endofanswer;

      ? e = 39 -> ppa still same word;	(single quote: interpreted as genitive)
      ? e = 34 -> ppa still same word;	(double quote: will be ignored)
      ? e = 45 -> ppa still same word;	(dash: used in composite words, ie. "semi-lit")
      ? e = 96 -> ppa still same word;	(backquote: italians approximate terminal accents)

      (checking letters a to z)

      ? e < 97 -> ppa check numbers now;
      ? e <= 122 -> ppa still same word;

      (checking numbers 0 to 9)

      "ppa check numbers now"
      ? e < 48 -> ppa found separator;
      ? e <= 57 -> ppa still same word;

      (if it's a punctuator or a blank, see if something else was found before it by
       checking flag as register D, and if it was, add a pointer to the former word
       to "answer word pointers", and terminate the word by replacing THIS punctuator
       with a null code; otherwise, increase C as the pointer to remember for next
       word, and skip the case of two separators with no significant chars. between)

      "ppa found separator"
      ? d = true -> ppa concrete new word;
	c +;
	-> ppa next char;

      "ppa concrete new word"
	[a minus 1 plus answer buffer] = null;
	[b plus answer word pointers] = c;
	[b plus answer word pointers] + answer buffer;
	b +;
	c = a;
	d = false;
	-> ppa next char;

      (if it's no separator, set flag as register D to remember that you've found significant
       characters between the previous separator and the actual character, and proceed...)

      "ppa still same word"
	d = true;
	-> ppa next char;

      (at the end of the string, you may have to add a record for the last word in the answer,
       whose effective presence is signalled by the fact that register D holds "true"...)

      "ppa endofanswer"
      ? d = false -> ppa no concrete final word;

	[a minus 1 plus answer buffer] = null;
	[b plus answer word pointers] = c;
	[b plus answer word pointers] + answer buffer;
	b +;

      (with or without a final word to register in the "answer word pointers" vector, here
       the loop ends and this subroutine proceeds to "service main loop" to let the storybook
       parser examine any possible matches with condition strings defined in the storybook)

      "ppa no concrete final word"
	[words in answer] = b;
	-> service main loop;

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				   SITUATION FILE LOAD/SAVE
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

      "load situation"
      ? [pointer to situation file name] = null -> situation file not present;

	[previous number of symbols] = [number of symbols];

	[file command] = read;
	[file name] = [pointer to situation file name];
	[file position] = zero;
	[block pointer] = situation file header;
	[block size] = 3 mtp bytes per unit;
	isocall;
      ? ok -> situation file present;

      "situation file not present"
	[session number] = zero;
	leave;

      "situation file present"
      ? [situation file header] = [storybook file checksum] -> valid situation file;

	[file name] = [pointer to situation file name];
	[file command] = destroy;
	isocall;

	[number of symbols] = [previous number of symbols];
	[session number] = zero;
	leave;

      "valid situation file"
	[file name] = [pointer to situation file name];
	[file command] = read;
	[file position] = 3 mtp bytes per unit;
	[block pointer] = symbols status;
	[block size] = [number of symbols];
	[block size] * bytes per unit;
	isocall;
	leave;

      "save situation"
      ? [pointer to situation file name] = null -> cant save situation;

	[situation file header] = [storybook file checksum];

	[file name] = [pointer to situation file name];
	[file command] = write;
	[file position] = zero;
	[block pointer] = situation file header;
	[block size] = 3 mtp bytes per unit;
	isocall;

	[file name] = [pointer to situation file name];
	[file command] = write;
	[file position] = 3 mtp bytes per unit;
	[block pointer] = symbols status;
	[block size] = [number of symbols];
	[block size] * bytes per unit;
	isocall;

      "cant save situation"
	leave;

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			 STRINGS AND DATASCRIPTS PROCESSING FUNCTIONS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

    "strlen"
    (finds out the length of 4b string pointed by [source string],
     giving result to variable [string length],
     not including the null terminator)
 ---->; a = [source string];
	b = zero;
      "strlen again"
      ? [a] = null -> strlen done;
	a +;
	b +;
	-> strlen again;
      "strlen done"
	[string length] = b;
 <----; leave;

    "strcpy"
    (copies 4b [source string] to 4b [target string])
 ---->; a = [target string];
    "strcpy strcat reentry"
	b = [source string];
      "strcpy again"
	[a] = [b];
	a +;
	b +;
      ? [b minus 1] != null -> strcpy again;
 <----; leave;

    "strcat"
    (concatenates 4b [source string] to 4b [target string])
 ---->; a = [target string];
      "strcat again"
      ? [a] = null -> strcpy strcat reentry;
	a +;
	-> strcat again;

    "strstr"
    (searchs 4b [target string] within 4b [source string],
     succeeds if match found, and returns match ptr. as [target string],
     fails otherwise, leaving [target string] unchanged,
     also fails unconditionally if one of the strings is void)
 ---->; a = [source string];
	b = [target string];
      ? [a] = null -> strstr match not found;
      ? [b] = null -> strstr match not found;
	c = [b];
	d = [a];
      "strstr again"
      ? d = null -> strstr match not found;
      ? c != d -> strstr fast skip;
	d = a;
	e = b;
      "strstr compare"
      ? [e plus 1] = null -> strstr match found;
      ? [d plus 1] = null -> strstr match not found;
      ? [d plus 1] != [e plus 1] -> strstr fast skip;
	d +;
	e +;
	-> strstr compare;
      "strstr fast skip"
	d = [a plus 1];
	a +;
	-> strstr again;
      "strstr match found"
	[target string] = a;
 <----; end;
      "strstr match not found"
 <----; fail;

    "dsexpand"
    (expands compact datascript packed in 7-bit as in "make: compact strings":
     - [source string] = 7-bit compact string being the head of the datascript
     - [target string] = output buffer, sized in units as 32/7th of in. buffer
     * requires "bits" library;
     * source 7-bit script must be terminated by hex code 7Fh, or decimal 127;
     * source 7-bit script must be followed if necessary, by a vector of units
       referenced by ASCII codes 1 to 7 in a compact string; code 1 references
       first unit, or unit at offset zero, of this vector; code 2 will be unit
       one, or the second unit, of this vector, and so on, until code 7: these
       7-bit codes will be replaced, in the output buffer, by the value of the
       corresponding unit of this vector. This is of course necessary whenever
       a unit that would be part of the expanded datascript wouldn't fit the 7
       bits of a single memory unit placed within compact strings, ASCII codes
       8 throught 126, and null terminators, still being translated normally.)
 ---->; [bit stream pointer] = [source string];
	[starting bit number] = zero;
	[bit field size] = 7;
	a = [target string];
	b = zero;
	b -->;
      "dse loop"
	a -->;
	=> get bit field;
	[starting bit number] + 7;
	<-- a;
	a +;
	b = [bit field content];
      ? b = 7fh -> dse endcs;
      ? b > 7 -> dse chars;
      ? b = 0 -> dse chars;
	a -->;
      "dse chars"
	[a minus 1] = b;
	-> dse loop;
      "dse endcs"
	a = [starting bit number];
	b = a;
	a > 5;
      ? b - 11111b -> dse sbn even;
	a +;
      "dse sbn even"
	a + [source string];
      "dse refill"
	<-- b;
	c = a;
      ? b = zero -> dse ready;
	c + [b minus 1];
	[b minus 1] = [c minus 1];
	-> dse refill;
      "dse ready"
 <----; leave;

    "csquestion"
    (wrapper to iGUI's "question", taking [question datascript] from a 7-bit
     encoded datascript to be processed with "dsexpand", and assuming there's
     the possibility to use "ffun cache" as a temporary buffer to hold the
     expanded version of the datascript...)
	[source string] = [question datascript];
	[target string] = ffun cache;
	=> dsexpand;
	[question datascript] = ffun cache;
	-> question;

    "csnotice"
    (as above, but calls "notice": a question without buttons or fields)
	[source string] = [question datascript];
	[target string] = ffun cache;
	=> dsexpand;
	[question datascript] = ffun cache;
	-> notice;

    "csrun"
    (expands 7-bit string pointed by [file name] and tells the system to run it)
	[source string] = [file name];
	[target string] = ffun cache;
	=> dsexpand;
	[file name] = ffun cache;
	[file command] = run;
	isocall;
	leave;

(~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				  File CoPY / File ConcATenate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~)

    "fcpy"
    (copies binary [source file], starting reading from [source fpos],
     to [target file], starting writing [target file] at [target fpos],
     reading and writing for upto [transf size] byts:
     both files must be shorter than 2^31 bytes - that is 2 Gb - in size,
     both <fpos> parameters are expressed in bytes and must be positive,
     if [transf size] is negative, e.g. minus 1, copies whole [source file],
     if [target file] doesn't exist, the routine creates it,
     if [target file] exists, and:
     - [target fpos] after end of [target file], extends [target file],
     - [target fpos] before end of [target file], overwrites the intersection,
     fails if it can't read from [source file] or write to [target file],
     succeeds, but does not touch [target file], if [source file] is void,
     or if [source file] is shorter than [source fpos].
     * preserves and returns all parameters and registers unchanged.)
	[source fpos] -->;
	[target fpos] -->;
	[transf size] -->;
      "fcpy fcat reentry"
      ? [source fpos] < zero -> fcpy error;
      ? [target fpos] < zero -> fcpy error;
      "fcpy loop"
      ? [transf size] = zero -> fcpy done;
	[file command] = read;
	[file name] = [source file];
	[file position] = [source fpos];
	[block pointer] = ffun cache;
	[block size] = sizeof ffun cache mtp bytes per unit;
	isocall;
      ? failed -> fcpy error;
      ? [block size] = zero -> fcpy done;
      ? [transf size] < zero -> fcpy no limit;
	[transf size] - [block size];
      ? [transf size] >= zero -> fcpy no limit;
	[block size] + [transf size];
	[transf size] = zero;
      "fcpy no limit"
      ? [fcpy callback] = null -> fcpy no callback;
	=> [fcpy callback];
      "fcpy no callback"
	[file command] = write;
	[file name] = [target file];
	[file position] = [target fpos];
	[block pointer] = ffun cache;
	[fcpy verify] = [block size];
	isocall;
      ? failed -> fcpy error;
      ? [fcpy verify] != [block size] -> fcpy error;
	[source fpos] + [block size];
	[target fpos] + [block size];
	-> fcpy loop;
      "fcpy done"
	<-- [transf size];
	<-- [target fpos];
	<-- [source fpos];
	end;
      "fcpy error"
	<-- [transf size];
	<-- [target fpos];
	<-- [source fpos];
	fail;

    "fcat"
    (concatenates [source file] to [target file], using "fcpy" entered with:
     - [source fpos] = zero;
     - [target fpos] = file size of [target file];
     - [transf size] = minus 1.
     * preserves and returns all parameters and registers unchanged.)
	[source fpos] -->;
	[target fpos] -->;
	[transf size] -->;
	[file command] = test;
	[file name] = [target file];
	isocall;
	[source fpos] = zero;
	[target fpos] = [file size];
	[transf size] = minus 1;
	-> fcpy fcat reentry;
